// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"mystats-server/internal/ent/batterrecord"
	"mystats-server/internal/ent/game"
	"mystats-server/internal/ent/pitcherrecord"
	"mystats-server/internal/ent/predicate"
	"mystats-server/internal/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBatterRecord  = "BatterRecord"
	TypeGame          = "Game"
	TypePitcherRecord = "PitcherRecord"
	TypeUser          = "User"
)

// BatterRecordMutation represents an operation that mutates the BatterRecord nodes in the graph.
type BatterRecordMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	games                *int
	addgames             *int
	avg                  *float64
	addavg               *float64
	plate_appearances    *int
	addplate_appearances *int
	at_bats              *int
	addat_bats           *int
	runs                 *int
	addruns              *int
	hits                 *int
	addhits              *int
	singles              *int
	addsingles           *int
	doubles              *int
	adddoubles           *int
	triples              *int
	addtriples           *int
	homeruns             *int
	addhomeruns          *int
	walks                *int
	addwalks             *int
	rbis                 *int
	addrbis              *int
	steals               *int
	addsteals            *int
	hit_by_pitch         *int
	addhit_by_pitch      *int
	strikeouts           *int
	addstrikeouts        *int
	double_plays         *int
	adddouble_plays      *int
	slg                  *float64
	addslg               *float64
	obp                  *float64
	addobp               *float64
	ops                  *float64
	addops               *float64
	bb_k                 *float64
	addbb_k              *float64
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	user                 *int
	cleareduser          bool
	game                 *int
	clearedgame          bool
	done                 bool
	oldValue             func(context.Context) (*BatterRecord, error)
	predicates           []predicate.BatterRecord
}

var _ ent.Mutation = (*BatterRecordMutation)(nil)

// batterrecordOption allows management of the mutation configuration using functional options.
type batterrecordOption func(*BatterRecordMutation)

// newBatterRecordMutation creates new mutation for the BatterRecord entity.
func newBatterRecordMutation(c config, op Op, opts ...batterrecordOption) *BatterRecordMutation {
	m := &BatterRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeBatterRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBatterRecordID sets the ID field of the mutation.
func withBatterRecordID(id int) batterrecordOption {
	return func(m *BatterRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *BatterRecord
		)
		m.oldValue = func(ctx context.Context) (*BatterRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BatterRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBatterRecord sets the old BatterRecord of the mutation.
func withBatterRecord(node *BatterRecord) batterrecordOption {
	return func(m *BatterRecordMutation) {
		m.oldValue = func(context.Context) (*BatterRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BatterRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BatterRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BatterRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BatterRecordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BatterRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGames sets the "games" field.
func (m *BatterRecordMutation) SetGames(i int) {
	m.games = &i
	m.addgames = nil
}

// Games returns the value of the "games" field in the mutation.
func (m *BatterRecordMutation) Games() (r int, exists bool) {
	v := m.games
	if v == nil {
		return
	}
	return *v, true
}

// OldGames returns the old "games" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldGames(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGames: %w", err)
	}
	return oldValue.Games, nil
}

// AddGames adds i to the "games" field.
func (m *BatterRecordMutation) AddGames(i int) {
	if m.addgames != nil {
		*m.addgames += i
	} else {
		m.addgames = &i
	}
}

// AddedGames returns the value that was added to the "games" field in this mutation.
func (m *BatterRecordMutation) AddedGames() (r int, exists bool) {
	v := m.addgames
	if v == nil {
		return
	}
	return *v, true
}

// ResetGames resets all changes to the "games" field.
func (m *BatterRecordMutation) ResetGames() {
	m.games = nil
	m.addgames = nil
}

// SetAvg sets the "avg" field.
func (m *BatterRecordMutation) SetAvg(f float64) {
	m.avg = &f
	m.addavg = nil
}

// Avg returns the value of the "avg" field in the mutation.
func (m *BatterRecordMutation) Avg() (r float64, exists bool) {
	v := m.avg
	if v == nil {
		return
	}
	return *v, true
}

// OldAvg returns the old "avg" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldAvg(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvg: %w", err)
	}
	return oldValue.Avg, nil
}

// AddAvg adds f to the "avg" field.
func (m *BatterRecordMutation) AddAvg(f float64) {
	if m.addavg != nil {
		*m.addavg += f
	} else {
		m.addavg = &f
	}
}

// AddedAvg returns the value that was added to the "avg" field in this mutation.
func (m *BatterRecordMutation) AddedAvg() (r float64, exists bool) {
	v := m.addavg
	if v == nil {
		return
	}
	return *v, true
}

// ClearAvg clears the value of the "avg" field.
func (m *BatterRecordMutation) ClearAvg() {
	m.avg = nil
	m.addavg = nil
	m.clearedFields[batterrecord.FieldAvg] = struct{}{}
}

// AvgCleared returns if the "avg" field was cleared in this mutation.
func (m *BatterRecordMutation) AvgCleared() bool {
	_, ok := m.clearedFields[batterrecord.FieldAvg]
	return ok
}

// ResetAvg resets all changes to the "avg" field.
func (m *BatterRecordMutation) ResetAvg() {
	m.avg = nil
	m.addavg = nil
	delete(m.clearedFields, batterrecord.FieldAvg)
}

// SetPlateAppearances sets the "plate_appearances" field.
func (m *BatterRecordMutation) SetPlateAppearances(i int) {
	m.plate_appearances = &i
	m.addplate_appearances = nil
}

// PlateAppearances returns the value of the "plate_appearances" field in the mutation.
func (m *BatterRecordMutation) PlateAppearances() (r int, exists bool) {
	v := m.plate_appearances
	if v == nil {
		return
	}
	return *v, true
}

// OldPlateAppearances returns the old "plate_appearances" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldPlateAppearances(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlateAppearances is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlateAppearances requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlateAppearances: %w", err)
	}
	return oldValue.PlateAppearances, nil
}

// AddPlateAppearances adds i to the "plate_appearances" field.
func (m *BatterRecordMutation) AddPlateAppearances(i int) {
	if m.addplate_appearances != nil {
		*m.addplate_appearances += i
	} else {
		m.addplate_appearances = &i
	}
}

// AddedPlateAppearances returns the value that was added to the "plate_appearances" field in this mutation.
func (m *BatterRecordMutation) AddedPlateAppearances() (r int, exists bool) {
	v := m.addplate_appearances
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlateAppearances resets all changes to the "plate_appearances" field.
func (m *BatterRecordMutation) ResetPlateAppearances() {
	m.plate_appearances = nil
	m.addplate_appearances = nil
}

// SetAtBats sets the "at_bats" field.
func (m *BatterRecordMutation) SetAtBats(i int) {
	m.at_bats = &i
	m.addat_bats = nil
}

// AtBats returns the value of the "at_bats" field in the mutation.
func (m *BatterRecordMutation) AtBats() (r int, exists bool) {
	v := m.at_bats
	if v == nil {
		return
	}
	return *v, true
}

// OldAtBats returns the old "at_bats" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldAtBats(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAtBats is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAtBats requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAtBats: %w", err)
	}
	return oldValue.AtBats, nil
}

// AddAtBats adds i to the "at_bats" field.
func (m *BatterRecordMutation) AddAtBats(i int) {
	if m.addat_bats != nil {
		*m.addat_bats += i
	} else {
		m.addat_bats = &i
	}
}

// AddedAtBats returns the value that was added to the "at_bats" field in this mutation.
func (m *BatterRecordMutation) AddedAtBats() (r int, exists bool) {
	v := m.addat_bats
	if v == nil {
		return
	}
	return *v, true
}

// ResetAtBats resets all changes to the "at_bats" field.
func (m *BatterRecordMutation) ResetAtBats() {
	m.at_bats = nil
	m.addat_bats = nil
}

// SetRuns sets the "runs" field.
func (m *BatterRecordMutation) SetRuns(i int) {
	m.runs = &i
	m.addruns = nil
}

// Runs returns the value of the "runs" field in the mutation.
func (m *BatterRecordMutation) Runs() (r int, exists bool) {
	v := m.runs
	if v == nil {
		return
	}
	return *v, true
}

// OldRuns returns the old "runs" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldRuns(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuns: %w", err)
	}
	return oldValue.Runs, nil
}

// AddRuns adds i to the "runs" field.
func (m *BatterRecordMutation) AddRuns(i int) {
	if m.addruns != nil {
		*m.addruns += i
	} else {
		m.addruns = &i
	}
}

// AddedRuns returns the value that was added to the "runs" field in this mutation.
func (m *BatterRecordMutation) AddedRuns() (r int, exists bool) {
	v := m.addruns
	if v == nil {
		return
	}
	return *v, true
}

// ResetRuns resets all changes to the "runs" field.
func (m *BatterRecordMutation) ResetRuns() {
	m.runs = nil
	m.addruns = nil
}

// SetHits sets the "hits" field.
func (m *BatterRecordMutation) SetHits(i int) {
	m.hits = &i
	m.addhits = nil
}

// Hits returns the value of the "hits" field in the mutation.
func (m *BatterRecordMutation) Hits() (r int, exists bool) {
	v := m.hits
	if v == nil {
		return
	}
	return *v, true
}

// OldHits returns the old "hits" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldHits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHits: %w", err)
	}
	return oldValue.Hits, nil
}

// AddHits adds i to the "hits" field.
func (m *BatterRecordMutation) AddHits(i int) {
	if m.addhits != nil {
		*m.addhits += i
	} else {
		m.addhits = &i
	}
}

// AddedHits returns the value that was added to the "hits" field in this mutation.
func (m *BatterRecordMutation) AddedHits() (r int, exists bool) {
	v := m.addhits
	if v == nil {
		return
	}
	return *v, true
}

// ResetHits resets all changes to the "hits" field.
func (m *BatterRecordMutation) ResetHits() {
	m.hits = nil
	m.addhits = nil
}

// SetSingles sets the "singles" field.
func (m *BatterRecordMutation) SetSingles(i int) {
	m.singles = &i
	m.addsingles = nil
}

// Singles returns the value of the "singles" field in the mutation.
func (m *BatterRecordMutation) Singles() (r int, exists bool) {
	v := m.singles
	if v == nil {
		return
	}
	return *v, true
}

// OldSingles returns the old "singles" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldSingles(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSingles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSingles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSingles: %w", err)
	}
	return oldValue.Singles, nil
}

// AddSingles adds i to the "singles" field.
func (m *BatterRecordMutation) AddSingles(i int) {
	if m.addsingles != nil {
		*m.addsingles += i
	} else {
		m.addsingles = &i
	}
}

// AddedSingles returns the value that was added to the "singles" field in this mutation.
func (m *BatterRecordMutation) AddedSingles() (r int, exists bool) {
	v := m.addsingles
	if v == nil {
		return
	}
	return *v, true
}

// ResetSingles resets all changes to the "singles" field.
func (m *BatterRecordMutation) ResetSingles() {
	m.singles = nil
	m.addsingles = nil
}

// SetDoubles sets the "doubles" field.
func (m *BatterRecordMutation) SetDoubles(i int) {
	m.doubles = &i
	m.adddoubles = nil
}

// Doubles returns the value of the "doubles" field in the mutation.
func (m *BatterRecordMutation) Doubles() (r int, exists bool) {
	v := m.doubles
	if v == nil {
		return
	}
	return *v, true
}

// OldDoubles returns the old "doubles" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldDoubles(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoubles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoubles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoubles: %w", err)
	}
	return oldValue.Doubles, nil
}

// AddDoubles adds i to the "doubles" field.
func (m *BatterRecordMutation) AddDoubles(i int) {
	if m.adddoubles != nil {
		*m.adddoubles += i
	} else {
		m.adddoubles = &i
	}
}

// AddedDoubles returns the value that was added to the "doubles" field in this mutation.
func (m *BatterRecordMutation) AddedDoubles() (r int, exists bool) {
	v := m.adddoubles
	if v == nil {
		return
	}
	return *v, true
}

// ResetDoubles resets all changes to the "doubles" field.
func (m *BatterRecordMutation) ResetDoubles() {
	m.doubles = nil
	m.adddoubles = nil
}

// SetTriples sets the "triples" field.
func (m *BatterRecordMutation) SetTriples(i int) {
	m.triples = &i
	m.addtriples = nil
}

// Triples returns the value of the "triples" field in the mutation.
func (m *BatterRecordMutation) Triples() (r int, exists bool) {
	v := m.triples
	if v == nil {
		return
	}
	return *v, true
}

// OldTriples returns the old "triples" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldTriples(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriples is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriples requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriples: %w", err)
	}
	return oldValue.Triples, nil
}

// AddTriples adds i to the "triples" field.
func (m *BatterRecordMutation) AddTriples(i int) {
	if m.addtriples != nil {
		*m.addtriples += i
	} else {
		m.addtriples = &i
	}
}

// AddedTriples returns the value that was added to the "triples" field in this mutation.
func (m *BatterRecordMutation) AddedTriples() (r int, exists bool) {
	v := m.addtriples
	if v == nil {
		return
	}
	return *v, true
}

// ResetTriples resets all changes to the "triples" field.
func (m *BatterRecordMutation) ResetTriples() {
	m.triples = nil
	m.addtriples = nil
}

// SetHomeruns sets the "homeruns" field.
func (m *BatterRecordMutation) SetHomeruns(i int) {
	m.homeruns = &i
	m.addhomeruns = nil
}

// Homeruns returns the value of the "homeruns" field in the mutation.
func (m *BatterRecordMutation) Homeruns() (r int, exists bool) {
	v := m.homeruns
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeruns returns the old "homeruns" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldHomeruns(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeruns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeruns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeruns: %w", err)
	}
	return oldValue.Homeruns, nil
}

// AddHomeruns adds i to the "homeruns" field.
func (m *BatterRecordMutation) AddHomeruns(i int) {
	if m.addhomeruns != nil {
		*m.addhomeruns += i
	} else {
		m.addhomeruns = &i
	}
}

// AddedHomeruns returns the value that was added to the "homeruns" field in this mutation.
func (m *BatterRecordMutation) AddedHomeruns() (r int, exists bool) {
	v := m.addhomeruns
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomeruns resets all changes to the "homeruns" field.
func (m *BatterRecordMutation) ResetHomeruns() {
	m.homeruns = nil
	m.addhomeruns = nil
}

// SetWalks sets the "walks" field.
func (m *BatterRecordMutation) SetWalks(i int) {
	m.walks = &i
	m.addwalks = nil
}

// Walks returns the value of the "walks" field in the mutation.
func (m *BatterRecordMutation) Walks() (r int, exists bool) {
	v := m.walks
	if v == nil {
		return
	}
	return *v, true
}

// OldWalks returns the old "walks" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldWalks(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWalks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWalks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalks: %w", err)
	}
	return oldValue.Walks, nil
}

// AddWalks adds i to the "walks" field.
func (m *BatterRecordMutation) AddWalks(i int) {
	if m.addwalks != nil {
		*m.addwalks += i
	} else {
		m.addwalks = &i
	}
}

// AddedWalks returns the value that was added to the "walks" field in this mutation.
func (m *BatterRecordMutation) AddedWalks() (r int, exists bool) {
	v := m.addwalks
	if v == nil {
		return
	}
	return *v, true
}

// ResetWalks resets all changes to the "walks" field.
func (m *BatterRecordMutation) ResetWalks() {
	m.walks = nil
	m.addwalks = nil
}

// SetRbis sets the "rbis" field.
func (m *BatterRecordMutation) SetRbis(i int) {
	m.rbis = &i
	m.addrbis = nil
}

// Rbis returns the value of the "rbis" field in the mutation.
func (m *BatterRecordMutation) Rbis() (r int, exists bool) {
	v := m.rbis
	if v == nil {
		return
	}
	return *v, true
}

// OldRbis returns the old "rbis" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldRbis(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRbis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRbis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRbis: %w", err)
	}
	return oldValue.Rbis, nil
}

// AddRbis adds i to the "rbis" field.
func (m *BatterRecordMutation) AddRbis(i int) {
	if m.addrbis != nil {
		*m.addrbis += i
	} else {
		m.addrbis = &i
	}
}

// AddedRbis returns the value that was added to the "rbis" field in this mutation.
func (m *BatterRecordMutation) AddedRbis() (r int, exists bool) {
	v := m.addrbis
	if v == nil {
		return
	}
	return *v, true
}

// ResetRbis resets all changes to the "rbis" field.
func (m *BatterRecordMutation) ResetRbis() {
	m.rbis = nil
	m.addrbis = nil
}

// SetSteals sets the "steals" field.
func (m *BatterRecordMutation) SetSteals(i int) {
	m.steals = &i
	m.addsteals = nil
}

// Steals returns the value of the "steals" field in the mutation.
func (m *BatterRecordMutation) Steals() (r int, exists bool) {
	v := m.steals
	if v == nil {
		return
	}
	return *v, true
}

// OldSteals returns the old "steals" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldSteals(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSteals is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSteals requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSteals: %w", err)
	}
	return oldValue.Steals, nil
}

// AddSteals adds i to the "steals" field.
func (m *BatterRecordMutation) AddSteals(i int) {
	if m.addsteals != nil {
		*m.addsteals += i
	} else {
		m.addsteals = &i
	}
}

// AddedSteals returns the value that was added to the "steals" field in this mutation.
func (m *BatterRecordMutation) AddedSteals() (r int, exists bool) {
	v := m.addsteals
	if v == nil {
		return
	}
	return *v, true
}

// ResetSteals resets all changes to the "steals" field.
func (m *BatterRecordMutation) ResetSteals() {
	m.steals = nil
	m.addsteals = nil
}

// SetHitByPitch sets the "hit_by_pitch" field.
func (m *BatterRecordMutation) SetHitByPitch(i int) {
	m.hit_by_pitch = &i
	m.addhit_by_pitch = nil
}

// HitByPitch returns the value of the "hit_by_pitch" field in the mutation.
func (m *BatterRecordMutation) HitByPitch() (r int, exists bool) {
	v := m.hit_by_pitch
	if v == nil {
		return
	}
	return *v, true
}

// OldHitByPitch returns the old "hit_by_pitch" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldHitByPitch(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHitByPitch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHitByPitch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHitByPitch: %w", err)
	}
	return oldValue.HitByPitch, nil
}

// AddHitByPitch adds i to the "hit_by_pitch" field.
func (m *BatterRecordMutation) AddHitByPitch(i int) {
	if m.addhit_by_pitch != nil {
		*m.addhit_by_pitch += i
	} else {
		m.addhit_by_pitch = &i
	}
}

// AddedHitByPitch returns the value that was added to the "hit_by_pitch" field in this mutation.
func (m *BatterRecordMutation) AddedHitByPitch() (r int, exists bool) {
	v := m.addhit_by_pitch
	if v == nil {
		return
	}
	return *v, true
}

// ResetHitByPitch resets all changes to the "hit_by_pitch" field.
func (m *BatterRecordMutation) ResetHitByPitch() {
	m.hit_by_pitch = nil
	m.addhit_by_pitch = nil
}

// SetStrikeouts sets the "strikeouts" field.
func (m *BatterRecordMutation) SetStrikeouts(i int) {
	m.strikeouts = &i
	m.addstrikeouts = nil
}

// Strikeouts returns the value of the "strikeouts" field in the mutation.
func (m *BatterRecordMutation) Strikeouts() (r int, exists bool) {
	v := m.strikeouts
	if v == nil {
		return
	}
	return *v, true
}

// OldStrikeouts returns the old "strikeouts" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldStrikeouts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrikeouts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrikeouts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrikeouts: %w", err)
	}
	return oldValue.Strikeouts, nil
}

// AddStrikeouts adds i to the "strikeouts" field.
func (m *BatterRecordMutation) AddStrikeouts(i int) {
	if m.addstrikeouts != nil {
		*m.addstrikeouts += i
	} else {
		m.addstrikeouts = &i
	}
}

// AddedStrikeouts returns the value that was added to the "strikeouts" field in this mutation.
func (m *BatterRecordMutation) AddedStrikeouts() (r int, exists bool) {
	v := m.addstrikeouts
	if v == nil {
		return
	}
	return *v, true
}

// ResetStrikeouts resets all changes to the "strikeouts" field.
func (m *BatterRecordMutation) ResetStrikeouts() {
	m.strikeouts = nil
	m.addstrikeouts = nil
}

// SetDoublePlays sets the "double_plays" field.
func (m *BatterRecordMutation) SetDoublePlays(i int) {
	m.double_plays = &i
	m.adddouble_plays = nil
}

// DoublePlays returns the value of the "double_plays" field in the mutation.
func (m *BatterRecordMutation) DoublePlays() (r int, exists bool) {
	v := m.double_plays
	if v == nil {
		return
	}
	return *v, true
}

// OldDoublePlays returns the old "double_plays" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldDoublePlays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoublePlays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoublePlays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoublePlays: %w", err)
	}
	return oldValue.DoublePlays, nil
}

// AddDoublePlays adds i to the "double_plays" field.
func (m *BatterRecordMutation) AddDoublePlays(i int) {
	if m.adddouble_plays != nil {
		*m.adddouble_plays += i
	} else {
		m.adddouble_plays = &i
	}
}

// AddedDoublePlays returns the value that was added to the "double_plays" field in this mutation.
func (m *BatterRecordMutation) AddedDoublePlays() (r int, exists bool) {
	v := m.adddouble_plays
	if v == nil {
		return
	}
	return *v, true
}

// ResetDoublePlays resets all changes to the "double_plays" field.
func (m *BatterRecordMutation) ResetDoublePlays() {
	m.double_plays = nil
	m.adddouble_plays = nil
}

// SetSlg sets the "slg" field.
func (m *BatterRecordMutation) SetSlg(f float64) {
	m.slg = &f
	m.addslg = nil
}

// Slg returns the value of the "slg" field in the mutation.
func (m *BatterRecordMutation) Slg() (r float64, exists bool) {
	v := m.slg
	if v == nil {
		return
	}
	return *v, true
}

// OldSlg returns the old "slg" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldSlg(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlg: %w", err)
	}
	return oldValue.Slg, nil
}

// AddSlg adds f to the "slg" field.
func (m *BatterRecordMutation) AddSlg(f float64) {
	if m.addslg != nil {
		*m.addslg += f
	} else {
		m.addslg = &f
	}
}

// AddedSlg returns the value that was added to the "slg" field in this mutation.
func (m *BatterRecordMutation) AddedSlg() (r float64, exists bool) {
	v := m.addslg
	if v == nil {
		return
	}
	return *v, true
}

// ClearSlg clears the value of the "slg" field.
func (m *BatterRecordMutation) ClearSlg() {
	m.slg = nil
	m.addslg = nil
	m.clearedFields[batterrecord.FieldSlg] = struct{}{}
}

// SlgCleared returns if the "slg" field was cleared in this mutation.
func (m *BatterRecordMutation) SlgCleared() bool {
	_, ok := m.clearedFields[batterrecord.FieldSlg]
	return ok
}

// ResetSlg resets all changes to the "slg" field.
func (m *BatterRecordMutation) ResetSlg() {
	m.slg = nil
	m.addslg = nil
	delete(m.clearedFields, batterrecord.FieldSlg)
}

// SetObp sets the "obp" field.
func (m *BatterRecordMutation) SetObp(f float64) {
	m.obp = &f
	m.addobp = nil
}

// Obp returns the value of the "obp" field in the mutation.
func (m *BatterRecordMutation) Obp() (r float64, exists bool) {
	v := m.obp
	if v == nil {
		return
	}
	return *v, true
}

// OldObp returns the old "obp" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldObp(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObp: %w", err)
	}
	return oldValue.Obp, nil
}

// AddObp adds f to the "obp" field.
func (m *BatterRecordMutation) AddObp(f float64) {
	if m.addobp != nil {
		*m.addobp += f
	} else {
		m.addobp = &f
	}
}

// AddedObp returns the value that was added to the "obp" field in this mutation.
func (m *BatterRecordMutation) AddedObp() (r float64, exists bool) {
	v := m.addobp
	if v == nil {
		return
	}
	return *v, true
}

// ClearObp clears the value of the "obp" field.
func (m *BatterRecordMutation) ClearObp() {
	m.obp = nil
	m.addobp = nil
	m.clearedFields[batterrecord.FieldObp] = struct{}{}
}

// ObpCleared returns if the "obp" field was cleared in this mutation.
func (m *BatterRecordMutation) ObpCleared() bool {
	_, ok := m.clearedFields[batterrecord.FieldObp]
	return ok
}

// ResetObp resets all changes to the "obp" field.
func (m *BatterRecordMutation) ResetObp() {
	m.obp = nil
	m.addobp = nil
	delete(m.clearedFields, batterrecord.FieldObp)
}

// SetOps sets the "ops" field.
func (m *BatterRecordMutation) SetOps(f float64) {
	m.ops = &f
	m.addops = nil
}

// Ops returns the value of the "ops" field in the mutation.
func (m *BatterRecordMutation) Ops() (r float64, exists bool) {
	v := m.ops
	if v == nil {
		return
	}
	return *v, true
}

// OldOps returns the old "ops" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldOps(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOps: %w", err)
	}
	return oldValue.Ops, nil
}

// AddOps adds f to the "ops" field.
func (m *BatterRecordMutation) AddOps(f float64) {
	if m.addops != nil {
		*m.addops += f
	} else {
		m.addops = &f
	}
}

// AddedOps returns the value that was added to the "ops" field in this mutation.
func (m *BatterRecordMutation) AddedOps() (r float64, exists bool) {
	v := m.addops
	if v == nil {
		return
	}
	return *v, true
}

// ClearOps clears the value of the "ops" field.
func (m *BatterRecordMutation) ClearOps() {
	m.ops = nil
	m.addops = nil
	m.clearedFields[batterrecord.FieldOps] = struct{}{}
}

// OpsCleared returns if the "ops" field was cleared in this mutation.
func (m *BatterRecordMutation) OpsCleared() bool {
	_, ok := m.clearedFields[batterrecord.FieldOps]
	return ok
}

// ResetOps resets all changes to the "ops" field.
func (m *BatterRecordMutation) ResetOps() {
	m.ops = nil
	m.addops = nil
	delete(m.clearedFields, batterrecord.FieldOps)
}

// SetBbK sets the "bb_k" field.
func (m *BatterRecordMutation) SetBbK(f float64) {
	m.bb_k = &f
	m.addbb_k = nil
}

// BbK returns the value of the "bb_k" field in the mutation.
func (m *BatterRecordMutation) BbK() (r float64, exists bool) {
	v := m.bb_k
	if v == nil {
		return
	}
	return *v, true
}

// OldBbK returns the old "bb_k" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldBbK(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBbK is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBbK requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBbK: %w", err)
	}
	return oldValue.BbK, nil
}

// AddBbK adds f to the "bb_k" field.
func (m *BatterRecordMutation) AddBbK(f float64) {
	if m.addbb_k != nil {
		*m.addbb_k += f
	} else {
		m.addbb_k = &f
	}
}

// AddedBbK returns the value that was added to the "bb_k" field in this mutation.
func (m *BatterRecordMutation) AddedBbK() (r float64, exists bool) {
	v := m.addbb_k
	if v == nil {
		return
	}
	return *v, true
}

// ClearBbK clears the value of the "bb_k" field.
func (m *BatterRecordMutation) ClearBbK() {
	m.bb_k = nil
	m.addbb_k = nil
	m.clearedFields[batterrecord.FieldBbK] = struct{}{}
}

// BbKCleared returns if the "bb_k" field was cleared in this mutation.
func (m *BatterRecordMutation) BbKCleared() bool {
	_, ok := m.clearedFields[batterrecord.FieldBbK]
	return ok
}

// ResetBbK resets all changes to the "bb_k" field.
func (m *BatterRecordMutation) ResetBbK() {
	m.bb_k = nil
	m.addbb_k = nil
	delete(m.clearedFields, batterrecord.FieldBbK)
}

// SetCreatedAt sets the "created_at" field.
func (m *BatterRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BatterRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BatterRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BatterRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BatterRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BatterRecord entity.
// If the BatterRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatterRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BatterRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *BatterRecordMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *BatterRecordMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *BatterRecordMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *BatterRecordMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BatterRecordMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *BatterRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetGameID sets the "game" edge to the Game entity by id.
func (m *BatterRecordMutation) SetGameID(id int) {
	m.game = &id
}

// ClearGame clears the "game" edge to the Game entity.
func (m *BatterRecordMutation) ClearGame() {
	m.clearedgame = true
}

// GameCleared reports if the "game" edge to the Game entity was cleared.
func (m *BatterRecordMutation) GameCleared() bool {
	return m.clearedgame
}

// GameID returns the "game" edge ID in the mutation.
func (m *BatterRecordMutation) GameID() (id int, exists bool) {
	if m.game != nil {
		return *m.game, true
	}
	return
}

// GameIDs returns the "game" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GameID instead. It exists only for internal usage by the builders.
func (m *BatterRecordMutation) GameIDs() (ids []int) {
	if id := m.game; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGame resets all changes to the "game" edge.
func (m *BatterRecordMutation) ResetGame() {
	m.game = nil
	m.clearedgame = false
}

// Where appends a list predicates to the BatterRecordMutation builder.
func (m *BatterRecordMutation) Where(ps ...predicate.BatterRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BatterRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BatterRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BatterRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BatterRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BatterRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BatterRecord).
func (m *BatterRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BatterRecordMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.games != nil {
		fields = append(fields, batterrecord.FieldGames)
	}
	if m.avg != nil {
		fields = append(fields, batterrecord.FieldAvg)
	}
	if m.plate_appearances != nil {
		fields = append(fields, batterrecord.FieldPlateAppearances)
	}
	if m.at_bats != nil {
		fields = append(fields, batterrecord.FieldAtBats)
	}
	if m.runs != nil {
		fields = append(fields, batterrecord.FieldRuns)
	}
	if m.hits != nil {
		fields = append(fields, batterrecord.FieldHits)
	}
	if m.singles != nil {
		fields = append(fields, batterrecord.FieldSingles)
	}
	if m.doubles != nil {
		fields = append(fields, batterrecord.FieldDoubles)
	}
	if m.triples != nil {
		fields = append(fields, batterrecord.FieldTriples)
	}
	if m.homeruns != nil {
		fields = append(fields, batterrecord.FieldHomeruns)
	}
	if m.walks != nil {
		fields = append(fields, batterrecord.FieldWalks)
	}
	if m.rbis != nil {
		fields = append(fields, batterrecord.FieldRbis)
	}
	if m.steals != nil {
		fields = append(fields, batterrecord.FieldSteals)
	}
	if m.hit_by_pitch != nil {
		fields = append(fields, batterrecord.FieldHitByPitch)
	}
	if m.strikeouts != nil {
		fields = append(fields, batterrecord.FieldStrikeouts)
	}
	if m.double_plays != nil {
		fields = append(fields, batterrecord.FieldDoublePlays)
	}
	if m.slg != nil {
		fields = append(fields, batterrecord.FieldSlg)
	}
	if m.obp != nil {
		fields = append(fields, batterrecord.FieldObp)
	}
	if m.ops != nil {
		fields = append(fields, batterrecord.FieldOps)
	}
	if m.bb_k != nil {
		fields = append(fields, batterrecord.FieldBbK)
	}
	if m.created_at != nil {
		fields = append(fields, batterrecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, batterrecord.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BatterRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case batterrecord.FieldGames:
		return m.Games()
	case batterrecord.FieldAvg:
		return m.Avg()
	case batterrecord.FieldPlateAppearances:
		return m.PlateAppearances()
	case batterrecord.FieldAtBats:
		return m.AtBats()
	case batterrecord.FieldRuns:
		return m.Runs()
	case batterrecord.FieldHits:
		return m.Hits()
	case batterrecord.FieldSingles:
		return m.Singles()
	case batterrecord.FieldDoubles:
		return m.Doubles()
	case batterrecord.FieldTriples:
		return m.Triples()
	case batterrecord.FieldHomeruns:
		return m.Homeruns()
	case batterrecord.FieldWalks:
		return m.Walks()
	case batterrecord.FieldRbis:
		return m.Rbis()
	case batterrecord.FieldSteals:
		return m.Steals()
	case batterrecord.FieldHitByPitch:
		return m.HitByPitch()
	case batterrecord.FieldStrikeouts:
		return m.Strikeouts()
	case batterrecord.FieldDoublePlays:
		return m.DoublePlays()
	case batterrecord.FieldSlg:
		return m.Slg()
	case batterrecord.FieldObp:
		return m.Obp()
	case batterrecord.FieldOps:
		return m.Ops()
	case batterrecord.FieldBbK:
		return m.BbK()
	case batterrecord.FieldCreatedAt:
		return m.CreatedAt()
	case batterrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BatterRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case batterrecord.FieldGames:
		return m.OldGames(ctx)
	case batterrecord.FieldAvg:
		return m.OldAvg(ctx)
	case batterrecord.FieldPlateAppearances:
		return m.OldPlateAppearances(ctx)
	case batterrecord.FieldAtBats:
		return m.OldAtBats(ctx)
	case batterrecord.FieldRuns:
		return m.OldRuns(ctx)
	case batterrecord.FieldHits:
		return m.OldHits(ctx)
	case batterrecord.FieldSingles:
		return m.OldSingles(ctx)
	case batterrecord.FieldDoubles:
		return m.OldDoubles(ctx)
	case batterrecord.FieldTriples:
		return m.OldTriples(ctx)
	case batterrecord.FieldHomeruns:
		return m.OldHomeruns(ctx)
	case batterrecord.FieldWalks:
		return m.OldWalks(ctx)
	case batterrecord.FieldRbis:
		return m.OldRbis(ctx)
	case batterrecord.FieldSteals:
		return m.OldSteals(ctx)
	case batterrecord.FieldHitByPitch:
		return m.OldHitByPitch(ctx)
	case batterrecord.FieldStrikeouts:
		return m.OldStrikeouts(ctx)
	case batterrecord.FieldDoublePlays:
		return m.OldDoublePlays(ctx)
	case batterrecord.FieldSlg:
		return m.OldSlg(ctx)
	case batterrecord.FieldObp:
		return m.OldObp(ctx)
	case batterrecord.FieldOps:
		return m.OldOps(ctx)
	case batterrecord.FieldBbK:
		return m.OldBbK(ctx)
	case batterrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case batterrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BatterRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatterRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case batterrecord.FieldGames:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGames(v)
		return nil
	case batterrecord.FieldAvg:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvg(v)
		return nil
	case batterrecord.FieldPlateAppearances:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlateAppearances(v)
		return nil
	case batterrecord.FieldAtBats:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAtBats(v)
		return nil
	case batterrecord.FieldRuns:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuns(v)
		return nil
	case batterrecord.FieldHits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHits(v)
		return nil
	case batterrecord.FieldSingles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSingles(v)
		return nil
	case batterrecord.FieldDoubles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoubles(v)
		return nil
	case batterrecord.FieldTriples:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriples(v)
		return nil
	case batterrecord.FieldHomeruns:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeruns(v)
		return nil
	case batterrecord.FieldWalks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalks(v)
		return nil
	case batterrecord.FieldRbis:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRbis(v)
		return nil
	case batterrecord.FieldSteals:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSteals(v)
		return nil
	case batterrecord.FieldHitByPitch:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHitByPitch(v)
		return nil
	case batterrecord.FieldStrikeouts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrikeouts(v)
		return nil
	case batterrecord.FieldDoublePlays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoublePlays(v)
		return nil
	case batterrecord.FieldSlg:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlg(v)
		return nil
	case batterrecord.FieldObp:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObp(v)
		return nil
	case batterrecord.FieldOps:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOps(v)
		return nil
	case batterrecord.FieldBbK:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBbK(v)
		return nil
	case batterrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case batterrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BatterRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BatterRecordMutation) AddedFields() []string {
	var fields []string
	if m.addgames != nil {
		fields = append(fields, batterrecord.FieldGames)
	}
	if m.addavg != nil {
		fields = append(fields, batterrecord.FieldAvg)
	}
	if m.addplate_appearances != nil {
		fields = append(fields, batterrecord.FieldPlateAppearances)
	}
	if m.addat_bats != nil {
		fields = append(fields, batterrecord.FieldAtBats)
	}
	if m.addruns != nil {
		fields = append(fields, batterrecord.FieldRuns)
	}
	if m.addhits != nil {
		fields = append(fields, batterrecord.FieldHits)
	}
	if m.addsingles != nil {
		fields = append(fields, batterrecord.FieldSingles)
	}
	if m.adddoubles != nil {
		fields = append(fields, batterrecord.FieldDoubles)
	}
	if m.addtriples != nil {
		fields = append(fields, batterrecord.FieldTriples)
	}
	if m.addhomeruns != nil {
		fields = append(fields, batterrecord.FieldHomeruns)
	}
	if m.addwalks != nil {
		fields = append(fields, batterrecord.FieldWalks)
	}
	if m.addrbis != nil {
		fields = append(fields, batterrecord.FieldRbis)
	}
	if m.addsteals != nil {
		fields = append(fields, batterrecord.FieldSteals)
	}
	if m.addhit_by_pitch != nil {
		fields = append(fields, batterrecord.FieldHitByPitch)
	}
	if m.addstrikeouts != nil {
		fields = append(fields, batterrecord.FieldStrikeouts)
	}
	if m.adddouble_plays != nil {
		fields = append(fields, batterrecord.FieldDoublePlays)
	}
	if m.addslg != nil {
		fields = append(fields, batterrecord.FieldSlg)
	}
	if m.addobp != nil {
		fields = append(fields, batterrecord.FieldObp)
	}
	if m.addops != nil {
		fields = append(fields, batterrecord.FieldOps)
	}
	if m.addbb_k != nil {
		fields = append(fields, batterrecord.FieldBbK)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BatterRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case batterrecord.FieldGames:
		return m.AddedGames()
	case batterrecord.FieldAvg:
		return m.AddedAvg()
	case batterrecord.FieldPlateAppearances:
		return m.AddedPlateAppearances()
	case batterrecord.FieldAtBats:
		return m.AddedAtBats()
	case batterrecord.FieldRuns:
		return m.AddedRuns()
	case batterrecord.FieldHits:
		return m.AddedHits()
	case batterrecord.FieldSingles:
		return m.AddedSingles()
	case batterrecord.FieldDoubles:
		return m.AddedDoubles()
	case batterrecord.FieldTriples:
		return m.AddedTriples()
	case batterrecord.FieldHomeruns:
		return m.AddedHomeruns()
	case batterrecord.FieldWalks:
		return m.AddedWalks()
	case batterrecord.FieldRbis:
		return m.AddedRbis()
	case batterrecord.FieldSteals:
		return m.AddedSteals()
	case batterrecord.FieldHitByPitch:
		return m.AddedHitByPitch()
	case batterrecord.FieldStrikeouts:
		return m.AddedStrikeouts()
	case batterrecord.FieldDoublePlays:
		return m.AddedDoublePlays()
	case batterrecord.FieldSlg:
		return m.AddedSlg()
	case batterrecord.FieldObp:
		return m.AddedObp()
	case batterrecord.FieldOps:
		return m.AddedOps()
	case batterrecord.FieldBbK:
		return m.AddedBbK()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatterRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case batterrecord.FieldGames:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGames(v)
		return nil
	case batterrecord.FieldAvg:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvg(v)
		return nil
	case batterrecord.FieldPlateAppearances:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlateAppearances(v)
		return nil
	case batterrecord.FieldAtBats:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAtBats(v)
		return nil
	case batterrecord.FieldRuns:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRuns(v)
		return nil
	case batterrecord.FieldHits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHits(v)
		return nil
	case batterrecord.FieldSingles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSingles(v)
		return nil
	case batterrecord.FieldDoubles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDoubles(v)
		return nil
	case batterrecord.FieldTriples:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTriples(v)
		return nil
	case batterrecord.FieldHomeruns:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeruns(v)
		return nil
	case batterrecord.FieldWalks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWalks(v)
		return nil
	case batterrecord.FieldRbis:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRbis(v)
		return nil
	case batterrecord.FieldSteals:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSteals(v)
		return nil
	case batterrecord.FieldHitByPitch:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHitByPitch(v)
		return nil
	case batterrecord.FieldStrikeouts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStrikeouts(v)
		return nil
	case batterrecord.FieldDoublePlays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDoublePlays(v)
		return nil
	case batterrecord.FieldSlg:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSlg(v)
		return nil
	case batterrecord.FieldObp:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddObp(v)
		return nil
	case batterrecord.FieldOps:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOps(v)
		return nil
	case batterrecord.FieldBbK:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBbK(v)
		return nil
	}
	return fmt.Errorf("unknown BatterRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BatterRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(batterrecord.FieldAvg) {
		fields = append(fields, batterrecord.FieldAvg)
	}
	if m.FieldCleared(batterrecord.FieldSlg) {
		fields = append(fields, batterrecord.FieldSlg)
	}
	if m.FieldCleared(batterrecord.FieldObp) {
		fields = append(fields, batterrecord.FieldObp)
	}
	if m.FieldCleared(batterrecord.FieldOps) {
		fields = append(fields, batterrecord.FieldOps)
	}
	if m.FieldCleared(batterrecord.FieldBbK) {
		fields = append(fields, batterrecord.FieldBbK)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BatterRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BatterRecordMutation) ClearField(name string) error {
	switch name {
	case batterrecord.FieldAvg:
		m.ClearAvg()
		return nil
	case batterrecord.FieldSlg:
		m.ClearSlg()
		return nil
	case batterrecord.FieldObp:
		m.ClearObp()
		return nil
	case batterrecord.FieldOps:
		m.ClearOps()
		return nil
	case batterrecord.FieldBbK:
		m.ClearBbK()
		return nil
	}
	return fmt.Errorf("unknown BatterRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BatterRecordMutation) ResetField(name string) error {
	switch name {
	case batterrecord.FieldGames:
		m.ResetGames()
		return nil
	case batterrecord.FieldAvg:
		m.ResetAvg()
		return nil
	case batterrecord.FieldPlateAppearances:
		m.ResetPlateAppearances()
		return nil
	case batterrecord.FieldAtBats:
		m.ResetAtBats()
		return nil
	case batterrecord.FieldRuns:
		m.ResetRuns()
		return nil
	case batterrecord.FieldHits:
		m.ResetHits()
		return nil
	case batterrecord.FieldSingles:
		m.ResetSingles()
		return nil
	case batterrecord.FieldDoubles:
		m.ResetDoubles()
		return nil
	case batterrecord.FieldTriples:
		m.ResetTriples()
		return nil
	case batterrecord.FieldHomeruns:
		m.ResetHomeruns()
		return nil
	case batterrecord.FieldWalks:
		m.ResetWalks()
		return nil
	case batterrecord.FieldRbis:
		m.ResetRbis()
		return nil
	case batterrecord.FieldSteals:
		m.ResetSteals()
		return nil
	case batterrecord.FieldHitByPitch:
		m.ResetHitByPitch()
		return nil
	case batterrecord.FieldStrikeouts:
		m.ResetStrikeouts()
		return nil
	case batterrecord.FieldDoublePlays:
		m.ResetDoublePlays()
		return nil
	case batterrecord.FieldSlg:
		m.ResetSlg()
		return nil
	case batterrecord.FieldObp:
		m.ResetObp()
		return nil
	case batterrecord.FieldOps:
		m.ResetOps()
		return nil
	case batterrecord.FieldBbK:
		m.ResetBbK()
		return nil
	case batterrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case batterrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BatterRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BatterRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, batterrecord.EdgeUser)
	}
	if m.game != nil {
		edges = append(edges, batterrecord.EdgeGame)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BatterRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case batterrecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case batterrecord.EdgeGame:
		if id := m.game; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BatterRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BatterRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BatterRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, batterrecord.EdgeUser)
	}
	if m.clearedgame {
		edges = append(edges, batterrecord.EdgeGame)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BatterRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case batterrecord.EdgeUser:
		return m.cleareduser
	case batterrecord.EdgeGame:
		return m.clearedgame
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BatterRecordMutation) ClearEdge(name string) error {
	switch name {
	case batterrecord.EdgeUser:
		m.ClearUser()
		return nil
	case batterrecord.EdgeGame:
		m.ClearGame()
		return nil
	}
	return fmt.Errorf("unknown BatterRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BatterRecordMutation) ResetEdge(name string) error {
	switch name {
	case batterrecord.EdgeUser:
		m.ResetUser()
		return nil
	case batterrecord.EdgeGame:
		m.ResetGame()
		return nil
	}
	return fmt.Errorf("unknown BatterRecord edge %s", name)
}

// GameMutation represents an operation that mutates the Game nodes in the graph.
type GameMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	date                    *time.Time
	opponent                *string
	location                *string
	result                  *string
	my_score                *int
	addmy_score             *int
	opponent_score          *int
	addopponent_score       *int
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	user                    *int
	cleareduser             bool
	batting_records         map[int]struct{}
	removedbatting_records  map[int]struct{}
	clearedbatting_records  bool
	pitching_records        map[int]struct{}
	removedpitching_records map[int]struct{}
	clearedpitching_records bool
	done                    bool
	oldValue                func(context.Context) (*Game, error)
	predicates              []predicate.Game
}

var _ ent.Mutation = (*GameMutation)(nil)

// gameOption allows management of the mutation configuration using functional options.
type gameOption func(*GameMutation)

// newGameMutation creates new mutation for the Game entity.
func newGameMutation(c config, op Op, opts ...gameOption) *GameMutation {
	m := &GameMutation{
		config:        c,
		op:            op,
		typ:           TypeGame,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameID sets the ID field of the mutation.
func withGameID(id int) gameOption {
	return func(m *GameMutation) {
		var (
			err   error
			once  sync.Once
			value *Game
		)
		m.oldValue = func(ctx context.Context) (*Game, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Game.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGame sets the old Game of the mutation.
func withGame(node *Game) gameOption {
	return func(m *GameMutation) {
		m.oldValue = func(context.Context) (*Game, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Game.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDate sets the "date" field.
func (m *GameMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *GameMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *GameMutation) ResetDate() {
	m.date = nil
}

// SetOpponent sets the "opponent" field.
func (m *GameMutation) SetOpponent(s string) {
	m.opponent = &s
}

// Opponent returns the value of the "opponent" field in the mutation.
func (m *GameMutation) Opponent() (r string, exists bool) {
	v := m.opponent
	if v == nil {
		return
	}
	return *v, true
}

// OldOpponent returns the old "opponent" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldOpponent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpponent: %w", err)
	}
	return oldValue.Opponent, nil
}

// ClearOpponent clears the value of the "opponent" field.
func (m *GameMutation) ClearOpponent() {
	m.opponent = nil
	m.clearedFields[game.FieldOpponent] = struct{}{}
}

// OpponentCleared returns if the "opponent" field was cleared in this mutation.
func (m *GameMutation) OpponentCleared() bool {
	_, ok := m.clearedFields[game.FieldOpponent]
	return ok
}

// ResetOpponent resets all changes to the "opponent" field.
func (m *GameMutation) ResetOpponent() {
	m.opponent = nil
	delete(m.clearedFields, game.FieldOpponent)
}

// SetLocation sets the "location" field.
func (m *GameMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *GameMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *GameMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[game.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *GameMutation) LocationCleared() bool {
	_, ok := m.clearedFields[game.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *GameMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, game.FieldLocation)
}

// SetResult sets the "result" field.
func (m *GameMutation) SetResult(s string) {
	m.result = &s
}

// Result returns the value of the "result" field in the mutation.
func (m *GameMutation) Result() (r string, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ClearResult clears the value of the "result" field.
func (m *GameMutation) ClearResult() {
	m.result = nil
	m.clearedFields[game.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *GameMutation) ResultCleared() bool {
	_, ok := m.clearedFields[game.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *GameMutation) ResetResult() {
	m.result = nil
	delete(m.clearedFields, game.FieldResult)
}

// SetMyScore sets the "my_score" field.
func (m *GameMutation) SetMyScore(i int) {
	m.my_score = &i
	m.addmy_score = nil
}

// MyScore returns the value of the "my_score" field in the mutation.
func (m *GameMutation) MyScore() (r int, exists bool) {
	v := m.my_score
	if v == nil {
		return
	}
	return *v, true
}

// OldMyScore returns the old "my_score" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldMyScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMyScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMyScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMyScore: %w", err)
	}
	return oldValue.MyScore, nil
}

// AddMyScore adds i to the "my_score" field.
func (m *GameMutation) AddMyScore(i int) {
	if m.addmy_score != nil {
		*m.addmy_score += i
	} else {
		m.addmy_score = &i
	}
}

// AddedMyScore returns the value that was added to the "my_score" field in this mutation.
func (m *GameMutation) AddedMyScore() (r int, exists bool) {
	v := m.addmy_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearMyScore clears the value of the "my_score" field.
func (m *GameMutation) ClearMyScore() {
	m.my_score = nil
	m.addmy_score = nil
	m.clearedFields[game.FieldMyScore] = struct{}{}
}

// MyScoreCleared returns if the "my_score" field was cleared in this mutation.
func (m *GameMutation) MyScoreCleared() bool {
	_, ok := m.clearedFields[game.FieldMyScore]
	return ok
}

// ResetMyScore resets all changes to the "my_score" field.
func (m *GameMutation) ResetMyScore() {
	m.my_score = nil
	m.addmy_score = nil
	delete(m.clearedFields, game.FieldMyScore)
}

// SetOpponentScore sets the "opponent_score" field.
func (m *GameMutation) SetOpponentScore(i int) {
	m.opponent_score = &i
	m.addopponent_score = nil
}

// OpponentScore returns the value of the "opponent_score" field in the mutation.
func (m *GameMutation) OpponentScore() (r int, exists bool) {
	v := m.opponent_score
	if v == nil {
		return
	}
	return *v, true
}

// OldOpponentScore returns the old "opponent_score" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldOpponentScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpponentScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpponentScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpponentScore: %w", err)
	}
	return oldValue.OpponentScore, nil
}

// AddOpponentScore adds i to the "opponent_score" field.
func (m *GameMutation) AddOpponentScore(i int) {
	if m.addopponent_score != nil {
		*m.addopponent_score += i
	} else {
		m.addopponent_score = &i
	}
}

// AddedOpponentScore returns the value that was added to the "opponent_score" field in this mutation.
func (m *GameMutation) AddedOpponentScore() (r int, exists bool) {
	v := m.addopponent_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearOpponentScore clears the value of the "opponent_score" field.
func (m *GameMutation) ClearOpponentScore() {
	m.opponent_score = nil
	m.addopponent_score = nil
	m.clearedFields[game.FieldOpponentScore] = struct{}{}
}

// OpponentScoreCleared returns if the "opponent_score" field was cleared in this mutation.
func (m *GameMutation) OpponentScoreCleared() bool {
	_, ok := m.clearedFields[game.FieldOpponentScore]
	return ok
}

// ResetOpponentScore resets all changes to the "opponent_score" field.
func (m *GameMutation) ResetOpponentScore() {
	m.opponent_score = nil
	m.addopponent_score = nil
	delete(m.clearedFields, game.FieldOpponentScore)
}

// SetCreatedAt sets the "created_at" field.
func (m *GameMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GameMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GameMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GameMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GameMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GameMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *GameMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *GameMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *GameMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *GameMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *GameMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *GameMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddBattingRecordIDs adds the "batting_records" edge to the BatterRecord entity by ids.
func (m *GameMutation) AddBattingRecordIDs(ids ...int) {
	if m.batting_records == nil {
		m.batting_records = make(map[int]struct{})
	}
	for i := range ids {
		m.batting_records[ids[i]] = struct{}{}
	}
}

// ClearBattingRecords clears the "batting_records" edge to the BatterRecord entity.
func (m *GameMutation) ClearBattingRecords() {
	m.clearedbatting_records = true
}

// BattingRecordsCleared reports if the "batting_records" edge to the BatterRecord entity was cleared.
func (m *GameMutation) BattingRecordsCleared() bool {
	return m.clearedbatting_records
}

// RemoveBattingRecordIDs removes the "batting_records" edge to the BatterRecord entity by IDs.
func (m *GameMutation) RemoveBattingRecordIDs(ids ...int) {
	if m.removedbatting_records == nil {
		m.removedbatting_records = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.batting_records, ids[i])
		m.removedbatting_records[ids[i]] = struct{}{}
	}
}

// RemovedBattingRecords returns the removed IDs of the "batting_records" edge to the BatterRecord entity.
func (m *GameMutation) RemovedBattingRecordsIDs() (ids []int) {
	for id := range m.removedbatting_records {
		ids = append(ids, id)
	}
	return
}

// BattingRecordsIDs returns the "batting_records" edge IDs in the mutation.
func (m *GameMutation) BattingRecordsIDs() (ids []int) {
	for id := range m.batting_records {
		ids = append(ids, id)
	}
	return
}

// ResetBattingRecords resets all changes to the "batting_records" edge.
func (m *GameMutation) ResetBattingRecords() {
	m.batting_records = nil
	m.clearedbatting_records = false
	m.removedbatting_records = nil
}

// AddPitchingRecordIDs adds the "pitching_records" edge to the PitcherRecord entity by ids.
func (m *GameMutation) AddPitchingRecordIDs(ids ...int) {
	if m.pitching_records == nil {
		m.pitching_records = make(map[int]struct{})
	}
	for i := range ids {
		m.pitching_records[ids[i]] = struct{}{}
	}
}

// ClearPitchingRecords clears the "pitching_records" edge to the PitcherRecord entity.
func (m *GameMutation) ClearPitchingRecords() {
	m.clearedpitching_records = true
}

// PitchingRecordsCleared reports if the "pitching_records" edge to the PitcherRecord entity was cleared.
func (m *GameMutation) PitchingRecordsCleared() bool {
	return m.clearedpitching_records
}

// RemovePitchingRecordIDs removes the "pitching_records" edge to the PitcherRecord entity by IDs.
func (m *GameMutation) RemovePitchingRecordIDs(ids ...int) {
	if m.removedpitching_records == nil {
		m.removedpitching_records = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.pitching_records, ids[i])
		m.removedpitching_records[ids[i]] = struct{}{}
	}
}

// RemovedPitchingRecords returns the removed IDs of the "pitching_records" edge to the PitcherRecord entity.
func (m *GameMutation) RemovedPitchingRecordsIDs() (ids []int) {
	for id := range m.removedpitching_records {
		ids = append(ids, id)
	}
	return
}

// PitchingRecordsIDs returns the "pitching_records" edge IDs in the mutation.
func (m *GameMutation) PitchingRecordsIDs() (ids []int) {
	for id := range m.pitching_records {
		ids = append(ids, id)
	}
	return
}

// ResetPitchingRecords resets all changes to the "pitching_records" edge.
func (m *GameMutation) ResetPitchingRecords() {
	m.pitching_records = nil
	m.clearedpitching_records = false
	m.removedpitching_records = nil
}

// Where appends a list predicates to the GameMutation builder.
func (m *GameMutation) Where(ps ...predicate.Game) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GameMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GameMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Game, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GameMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GameMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Game).
func (m *GameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.date != nil {
		fields = append(fields, game.FieldDate)
	}
	if m.opponent != nil {
		fields = append(fields, game.FieldOpponent)
	}
	if m.location != nil {
		fields = append(fields, game.FieldLocation)
	}
	if m.result != nil {
		fields = append(fields, game.FieldResult)
	}
	if m.my_score != nil {
		fields = append(fields, game.FieldMyScore)
	}
	if m.opponent_score != nil {
		fields = append(fields, game.FieldOpponentScore)
	}
	if m.created_at != nil {
		fields = append(fields, game.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, game.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case game.FieldDate:
		return m.Date()
	case game.FieldOpponent:
		return m.Opponent()
	case game.FieldLocation:
		return m.Location()
	case game.FieldResult:
		return m.Result()
	case game.FieldMyScore:
		return m.MyScore()
	case game.FieldOpponentScore:
		return m.OpponentScore()
	case game.FieldCreatedAt:
		return m.CreatedAt()
	case game.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case game.FieldDate:
		return m.OldDate(ctx)
	case game.FieldOpponent:
		return m.OldOpponent(ctx)
	case game.FieldLocation:
		return m.OldLocation(ctx)
	case game.FieldResult:
		return m.OldResult(ctx)
	case game.FieldMyScore:
		return m.OldMyScore(ctx)
	case game.FieldOpponentScore:
		return m.OldOpponentScore(ctx)
	case game.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case game.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Game field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case game.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case game.FieldOpponent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpponent(v)
		return nil
	case game.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case game.FieldResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case game.FieldMyScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMyScore(v)
		return nil
	case game.FieldOpponentScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpponentScore(v)
		return nil
	case game.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case game.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Game field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameMutation) AddedFields() []string {
	var fields []string
	if m.addmy_score != nil {
		fields = append(fields, game.FieldMyScore)
	}
	if m.addopponent_score != nil {
		fields = append(fields, game.FieldOpponentScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case game.FieldMyScore:
		return m.AddedMyScore()
	case game.FieldOpponentScore:
		return m.AddedOpponentScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameMutation) AddField(name string, value ent.Value) error {
	switch name {
	case game.FieldMyScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMyScore(v)
		return nil
	case game.FieldOpponentScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpponentScore(v)
		return nil
	}
	return fmt.Errorf("unknown Game numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(game.FieldOpponent) {
		fields = append(fields, game.FieldOpponent)
	}
	if m.FieldCleared(game.FieldLocation) {
		fields = append(fields, game.FieldLocation)
	}
	if m.FieldCleared(game.FieldResult) {
		fields = append(fields, game.FieldResult)
	}
	if m.FieldCleared(game.FieldMyScore) {
		fields = append(fields, game.FieldMyScore)
	}
	if m.FieldCleared(game.FieldOpponentScore) {
		fields = append(fields, game.FieldOpponentScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameMutation) ClearField(name string) error {
	switch name {
	case game.FieldOpponent:
		m.ClearOpponent()
		return nil
	case game.FieldLocation:
		m.ClearLocation()
		return nil
	case game.FieldResult:
		m.ClearResult()
		return nil
	case game.FieldMyScore:
		m.ClearMyScore()
		return nil
	case game.FieldOpponentScore:
		m.ClearOpponentScore()
		return nil
	}
	return fmt.Errorf("unknown Game nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameMutation) ResetField(name string) error {
	switch name {
	case game.FieldDate:
		m.ResetDate()
		return nil
	case game.FieldOpponent:
		m.ResetOpponent()
		return nil
	case game.FieldLocation:
		m.ResetLocation()
		return nil
	case game.FieldResult:
		m.ResetResult()
		return nil
	case game.FieldMyScore:
		m.ResetMyScore()
		return nil
	case game.FieldOpponentScore:
		m.ResetOpponentScore()
		return nil
	case game.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case game.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Game field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, game.EdgeUser)
	}
	if m.batting_records != nil {
		edges = append(edges, game.EdgeBattingRecords)
	}
	if m.pitching_records != nil {
		edges = append(edges, game.EdgePitchingRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case game.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case game.EdgeBattingRecords:
		ids := make([]ent.Value, 0, len(m.batting_records))
		for id := range m.batting_records {
			ids = append(ids, id)
		}
		return ids
	case game.EdgePitchingRecords:
		ids := make([]ent.Value, 0, len(m.pitching_records))
		for id := range m.pitching_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbatting_records != nil {
		edges = append(edges, game.EdgeBattingRecords)
	}
	if m.removedpitching_records != nil {
		edges = append(edges, game.EdgePitchingRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case game.EdgeBattingRecords:
		ids := make([]ent.Value, 0, len(m.removedbatting_records))
		for id := range m.removedbatting_records {
			ids = append(ids, id)
		}
		return ids
	case game.EdgePitchingRecords:
		ids := make([]ent.Value, 0, len(m.removedpitching_records))
		for id := range m.removedpitching_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, game.EdgeUser)
	}
	if m.clearedbatting_records {
		edges = append(edges, game.EdgeBattingRecords)
	}
	if m.clearedpitching_records {
		edges = append(edges, game.EdgePitchingRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameMutation) EdgeCleared(name string) bool {
	switch name {
	case game.EdgeUser:
		return m.cleareduser
	case game.EdgeBattingRecords:
		return m.clearedbatting_records
	case game.EdgePitchingRecords:
		return m.clearedpitching_records
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameMutation) ClearEdge(name string) error {
	switch name {
	case game.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Game unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameMutation) ResetEdge(name string) error {
	switch name {
	case game.EdgeUser:
		m.ResetUser()
		return nil
	case game.EdgeBattingRecords:
		m.ResetBattingRecords()
		return nil
	case game.EdgePitchingRecords:
		m.ResetPitchingRecords()
		return nil
	}
	return fmt.Errorf("unknown Game edge %s", name)
}

// PitcherRecordMutation represents an operation that mutates the PitcherRecord nodes in the graph.
type PitcherRecordMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	games               *int
	addgames            *int
	era                 *float64
	addera              *float64
	wins                *int
	addwins             *int
	losses              *int
	addlosses           *int
	saves               *int
	addsaves            *int
	holds               *int
	addholds            *int
	winning_pct         *float64
	addwinning_pct      *float64
	batters_faced       *int
	addbatters_faced    *int
	opponent_at_bats    *int
	addopponent_at_bats *int
	innings             *float64
	addinnings          *float64
	hits_allowed        *int
	addhits_allowed     *int
	homeruns_allowed    *int
	addhomeruns_allowed *int
	walks               *int
	addwalks            *int
	hit_by_pitch        *int
	addhit_by_pitch     *int
	strikeouts          *int
	addstrikeouts       *int
	earned_runs         *int
	addearned_runs      *int
	whip                *float64
	addwhip             *float64
	opponent_avg        *float64
	addopponent_avg     *float64
	strikeout_rate      *float64
	addstrikeout_rate   *float64
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	user                *int
	cleareduser         bool
	game                *int
	clearedgame         bool
	done                bool
	oldValue            func(context.Context) (*PitcherRecord, error)
	predicates          []predicate.PitcherRecord
}

var _ ent.Mutation = (*PitcherRecordMutation)(nil)

// pitcherrecordOption allows management of the mutation configuration using functional options.
type pitcherrecordOption func(*PitcherRecordMutation)

// newPitcherRecordMutation creates new mutation for the PitcherRecord entity.
func newPitcherRecordMutation(c config, op Op, opts ...pitcherrecordOption) *PitcherRecordMutation {
	m := &PitcherRecordMutation{
		config:        c,
		op:            op,
		typ:           TypePitcherRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPitcherRecordID sets the ID field of the mutation.
func withPitcherRecordID(id int) pitcherrecordOption {
	return func(m *PitcherRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *PitcherRecord
		)
		m.oldValue = func(ctx context.Context) (*PitcherRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PitcherRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPitcherRecord sets the old PitcherRecord of the mutation.
func withPitcherRecord(node *PitcherRecord) pitcherrecordOption {
	return func(m *PitcherRecordMutation) {
		m.oldValue = func(context.Context) (*PitcherRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PitcherRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PitcherRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PitcherRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PitcherRecordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PitcherRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGames sets the "games" field.
func (m *PitcherRecordMutation) SetGames(i int) {
	m.games = &i
	m.addgames = nil
}

// Games returns the value of the "games" field in the mutation.
func (m *PitcherRecordMutation) Games() (r int, exists bool) {
	v := m.games
	if v == nil {
		return
	}
	return *v, true
}

// OldGames returns the old "games" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldGames(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGames: %w", err)
	}
	return oldValue.Games, nil
}

// AddGames adds i to the "games" field.
func (m *PitcherRecordMutation) AddGames(i int) {
	if m.addgames != nil {
		*m.addgames += i
	} else {
		m.addgames = &i
	}
}

// AddedGames returns the value that was added to the "games" field in this mutation.
func (m *PitcherRecordMutation) AddedGames() (r int, exists bool) {
	v := m.addgames
	if v == nil {
		return
	}
	return *v, true
}

// ResetGames resets all changes to the "games" field.
func (m *PitcherRecordMutation) ResetGames() {
	m.games = nil
	m.addgames = nil
}

// SetEra sets the "era" field.
func (m *PitcherRecordMutation) SetEra(f float64) {
	m.era = &f
	m.addera = nil
}

// Era returns the value of the "era" field in the mutation.
func (m *PitcherRecordMutation) Era() (r float64, exists bool) {
	v := m.era
	if v == nil {
		return
	}
	return *v, true
}

// OldEra returns the old "era" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldEra(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEra: %w", err)
	}
	return oldValue.Era, nil
}

// AddEra adds f to the "era" field.
func (m *PitcherRecordMutation) AddEra(f float64) {
	if m.addera != nil {
		*m.addera += f
	} else {
		m.addera = &f
	}
}

// AddedEra returns the value that was added to the "era" field in this mutation.
func (m *PitcherRecordMutation) AddedEra() (r float64, exists bool) {
	v := m.addera
	if v == nil {
		return
	}
	return *v, true
}

// ClearEra clears the value of the "era" field.
func (m *PitcherRecordMutation) ClearEra() {
	m.era = nil
	m.addera = nil
	m.clearedFields[pitcherrecord.FieldEra] = struct{}{}
}

// EraCleared returns if the "era" field was cleared in this mutation.
func (m *PitcherRecordMutation) EraCleared() bool {
	_, ok := m.clearedFields[pitcherrecord.FieldEra]
	return ok
}

// ResetEra resets all changes to the "era" field.
func (m *PitcherRecordMutation) ResetEra() {
	m.era = nil
	m.addera = nil
	delete(m.clearedFields, pitcherrecord.FieldEra)
}

// SetWins sets the "wins" field.
func (m *PitcherRecordMutation) SetWins(i int) {
	m.wins = &i
	m.addwins = nil
}

// Wins returns the value of the "wins" field in the mutation.
func (m *PitcherRecordMutation) Wins() (r int, exists bool) {
	v := m.wins
	if v == nil {
		return
	}
	return *v, true
}

// OldWins returns the old "wins" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldWins(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWins is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWins requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWins: %w", err)
	}
	return oldValue.Wins, nil
}

// AddWins adds i to the "wins" field.
func (m *PitcherRecordMutation) AddWins(i int) {
	if m.addwins != nil {
		*m.addwins += i
	} else {
		m.addwins = &i
	}
}

// AddedWins returns the value that was added to the "wins" field in this mutation.
func (m *PitcherRecordMutation) AddedWins() (r int, exists bool) {
	v := m.addwins
	if v == nil {
		return
	}
	return *v, true
}

// ResetWins resets all changes to the "wins" field.
func (m *PitcherRecordMutation) ResetWins() {
	m.wins = nil
	m.addwins = nil
}

// SetLosses sets the "losses" field.
func (m *PitcherRecordMutation) SetLosses(i int) {
	m.losses = &i
	m.addlosses = nil
}

// Losses returns the value of the "losses" field in the mutation.
func (m *PitcherRecordMutation) Losses() (r int, exists bool) {
	v := m.losses
	if v == nil {
		return
	}
	return *v, true
}

// OldLosses returns the old "losses" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldLosses(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLosses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLosses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLosses: %w", err)
	}
	return oldValue.Losses, nil
}

// AddLosses adds i to the "losses" field.
func (m *PitcherRecordMutation) AddLosses(i int) {
	if m.addlosses != nil {
		*m.addlosses += i
	} else {
		m.addlosses = &i
	}
}

// AddedLosses returns the value that was added to the "losses" field in this mutation.
func (m *PitcherRecordMutation) AddedLosses() (r int, exists bool) {
	v := m.addlosses
	if v == nil {
		return
	}
	return *v, true
}

// ResetLosses resets all changes to the "losses" field.
func (m *PitcherRecordMutation) ResetLosses() {
	m.losses = nil
	m.addlosses = nil
}

// SetSaves sets the "saves" field.
func (m *PitcherRecordMutation) SetSaves(i int) {
	m.saves = &i
	m.addsaves = nil
}

// Saves returns the value of the "saves" field in the mutation.
func (m *PitcherRecordMutation) Saves() (r int, exists bool) {
	v := m.saves
	if v == nil {
		return
	}
	return *v, true
}

// OldSaves returns the old "saves" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldSaves(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaves is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaves requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaves: %w", err)
	}
	return oldValue.Saves, nil
}

// AddSaves adds i to the "saves" field.
func (m *PitcherRecordMutation) AddSaves(i int) {
	if m.addsaves != nil {
		*m.addsaves += i
	} else {
		m.addsaves = &i
	}
}

// AddedSaves returns the value that was added to the "saves" field in this mutation.
func (m *PitcherRecordMutation) AddedSaves() (r int, exists bool) {
	v := m.addsaves
	if v == nil {
		return
	}
	return *v, true
}

// ResetSaves resets all changes to the "saves" field.
func (m *PitcherRecordMutation) ResetSaves() {
	m.saves = nil
	m.addsaves = nil
}

// SetHolds sets the "holds" field.
func (m *PitcherRecordMutation) SetHolds(i int) {
	m.holds = &i
	m.addholds = nil
}

// Holds returns the value of the "holds" field in the mutation.
func (m *PitcherRecordMutation) Holds() (r int, exists bool) {
	v := m.holds
	if v == nil {
		return
	}
	return *v, true
}

// OldHolds returns the old "holds" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldHolds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHolds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHolds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHolds: %w", err)
	}
	return oldValue.Holds, nil
}

// AddHolds adds i to the "holds" field.
func (m *PitcherRecordMutation) AddHolds(i int) {
	if m.addholds != nil {
		*m.addholds += i
	} else {
		m.addholds = &i
	}
}

// AddedHolds returns the value that was added to the "holds" field in this mutation.
func (m *PitcherRecordMutation) AddedHolds() (r int, exists bool) {
	v := m.addholds
	if v == nil {
		return
	}
	return *v, true
}

// ResetHolds resets all changes to the "holds" field.
func (m *PitcherRecordMutation) ResetHolds() {
	m.holds = nil
	m.addholds = nil
}

// SetWinningPct sets the "winning_pct" field.
func (m *PitcherRecordMutation) SetWinningPct(f float64) {
	m.winning_pct = &f
	m.addwinning_pct = nil
}

// WinningPct returns the value of the "winning_pct" field in the mutation.
func (m *PitcherRecordMutation) WinningPct() (r float64, exists bool) {
	v := m.winning_pct
	if v == nil {
		return
	}
	return *v, true
}

// OldWinningPct returns the old "winning_pct" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldWinningPct(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWinningPct is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWinningPct requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWinningPct: %w", err)
	}
	return oldValue.WinningPct, nil
}

// AddWinningPct adds f to the "winning_pct" field.
func (m *PitcherRecordMutation) AddWinningPct(f float64) {
	if m.addwinning_pct != nil {
		*m.addwinning_pct += f
	} else {
		m.addwinning_pct = &f
	}
}

// AddedWinningPct returns the value that was added to the "winning_pct" field in this mutation.
func (m *PitcherRecordMutation) AddedWinningPct() (r float64, exists bool) {
	v := m.addwinning_pct
	if v == nil {
		return
	}
	return *v, true
}

// ClearWinningPct clears the value of the "winning_pct" field.
func (m *PitcherRecordMutation) ClearWinningPct() {
	m.winning_pct = nil
	m.addwinning_pct = nil
	m.clearedFields[pitcherrecord.FieldWinningPct] = struct{}{}
}

// WinningPctCleared returns if the "winning_pct" field was cleared in this mutation.
func (m *PitcherRecordMutation) WinningPctCleared() bool {
	_, ok := m.clearedFields[pitcherrecord.FieldWinningPct]
	return ok
}

// ResetWinningPct resets all changes to the "winning_pct" field.
func (m *PitcherRecordMutation) ResetWinningPct() {
	m.winning_pct = nil
	m.addwinning_pct = nil
	delete(m.clearedFields, pitcherrecord.FieldWinningPct)
}

// SetBattersFaced sets the "batters_faced" field.
func (m *PitcherRecordMutation) SetBattersFaced(i int) {
	m.batters_faced = &i
	m.addbatters_faced = nil
}

// BattersFaced returns the value of the "batters_faced" field in the mutation.
func (m *PitcherRecordMutation) BattersFaced() (r int, exists bool) {
	v := m.batters_faced
	if v == nil {
		return
	}
	return *v, true
}

// OldBattersFaced returns the old "batters_faced" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldBattersFaced(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBattersFaced is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBattersFaced requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBattersFaced: %w", err)
	}
	return oldValue.BattersFaced, nil
}

// AddBattersFaced adds i to the "batters_faced" field.
func (m *PitcherRecordMutation) AddBattersFaced(i int) {
	if m.addbatters_faced != nil {
		*m.addbatters_faced += i
	} else {
		m.addbatters_faced = &i
	}
}

// AddedBattersFaced returns the value that was added to the "batters_faced" field in this mutation.
func (m *PitcherRecordMutation) AddedBattersFaced() (r int, exists bool) {
	v := m.addbatters_faced
	if v == nil {
		return
	}
	return *v, true
}

// ResetBattersFaced resets all changes to the "batters_faced" field.
func (m *PitcherRecordMutation) ResetBattersFaced() {
	m.batters_faced = nil
	m.addbatters_faced = nil
}

// SetOpponentAtBats sets the "opponent_at_bats" field.
func (m *PitcherRecordMutation) SetOpponentAtBats(i int) {
	m.opponent_at_bats = &i
	m.addopponent_at_bats = nil
}

// OpponentAtBats returns the value of the "opponent_at_bats" field in the mutation.
func (m *PitcherRecordMutation) OpponentAtBats() (r int, exists bool) {
	v := m.opponent_at_bats
	if v == nil {
		return
	}
	return *v, true
}

// OldOpponentAtBats returns the old "opponent_at_bats" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldOpponentAtBats(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpponentAtBats is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpponentAtBats requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpponentAtBats: %w", err)
	}
	return oldValue.OpponentAtBats, nil
}

// AddOpponentAtBats adds i to the "opponent_at_bats" field.
func (m *PitcherRecordMutation) AddOpponentAtBats(i int) {
	if m.addopponent_at_bats != nil {
		*m.addopponent_at_bats += i
	} else {
		m.addopponent_at_bats = &i
	}
}

// AddedOpponentAtBats returns the value that was added to the "opponent_at_bats" field in this mutation.
func (m *PitcherRecordMutation) AddedOpponentAtBats() (r int, exists bool) {
	v := m.addopponent_at_bats
	if v == nil {
		return
	}
	return *v, true
}

// ResetOpponentAtBats resets all changes to the "opponent_at_bats" field.
func (m *PitcherRecordMutation) ResetOpponentAtBats() {
	m.opponent_at_bats = nil
	m.addopponent_at_bats = nil
}

// SetInnings sets the "innings" field.
func (m *PitcherRecordMutation) SetInnings(f float64) {
	m.innings = &f
	m.addinnings = nil
}

// Innings returns the value of the "innings" field in the mutation.
func (m *PitcherRecordMutation) Innings() (r float64, exists bool) {
	v := m.innings
	if v == nil {
		return
	}
	return *v, true
}

// OldInnings returns the old "innings" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldInnings(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInnings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInnings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInnings: %w", err)
	}
	return oldValue.Innings, nil
}

// AddInnings adds f to the "innings" field.
func (m *PitcherRecordMutation) AddInnings(f float64) {
	if m.addinnings != nil {
		*m.addinnings += f
	} else {
		m.addinnings = &f
	}
}

// AddedInnings returns the value that was added to the "innings" field in this mutation.
func (m *PitcherRecordMutation) AddedInnings() (r float64, exists bool) {
	v := m.addinnings
	if v == nil {
		return
	}
	return *v, true
}

// ResetInnings resets all changes to the "innings" field.
func (m *PitcherRecordMutation) ResetInnings() {
	m.innings = nil
	m.addinnings = nil
}

// SetHitsAllowed sets the "hits_allowed" field.
func (m *PitcherRecordMutation) SetHitsAllowed(i int) {
	m.hits_allowed = &i
	m.addhits_allowed = nil
}

// HitsAllowed returns the value of the "hits_allowed" field in the mutation.
func (m *PitcherRecordMutation) HitsAllowed() (r int, exists bool) {
	v := m.hits_allowed
	if v == nil {
		return
	}
	return *v, true
}

// OldHitsAllowed returns the old "hits_allowed" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldHitsAllowed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHitsAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHitsAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHitsAllowed: %w", err)
	}
	return oldValue.HitsAllowed, nil
}

// AddHitsAllowed adds i to the "hits_allowed" field.
func (m *PitcherRecordMutation) AddHitsAllowed(i int) {
	if m.addhits_allowed != nil {
		*m.addhits_allowed += i
	} else {
		m.addhits_allowed = &i
	}
}

// AddedHitsAllowed returns the value that was added to the "hits_allowed" field in this mutation.
func (m *PitcherRecordMutation) AddedHitsAllowed() (r int, exists bool) {
	v := m.addhits_allowed
	if v == nil {
		return
	}
	return *v, true
}

// ResetHitsAllowed resets all changes to the "hits_allowed" field.
func (m *PitcherRecordMutation) ResetHitsAllowed() {
	m.hits_allowed = nil
	m.addhits_allowed = nil
}

// SetHomerunsAllowed sets the "homeruns_allowed" field.
func (m *PitcherRecordMutation) SetHomerunsAllowed(i int) {
	m.homeruns_allowed = &i
	m.addhomeruns_allowed = nil
}

// HomerunsAllowed returns the value of the "homeruns_allowed" field in the mutation.
func (m *PitcherRecordMutation) HomerunsAllowed() (r int, exists bool) {
	v := m.homeruns_allowed
	if v == nil {
		return
	}
	return *v, true
}

// OldHomerunsAllowed returns the old "homeruns_allowed" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldHomerunsAllowed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomerunsAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomerunsAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomerunsAllowed: %w", err)
	}
	return oldValue.HomerunsAllowed, nil
}

// AddHomerunsAllowed adds i to the "homeruns_allowed" field.
func (m *PitcherRecordMutation) AddHomerunsAllowed(i int) {
	if m.addhomeruns_allowed != nil {
		*m.addhomeruns_allowed += i
	} else {
		m.addhomeruns_allowed = &i
	}
}

// AddedHomerunsAllowed returns the value that was added to the "homeruns_allowed" field in this mutation.
func (m *PitcherRecordMutation) AddedHomerunsAllowed() (r int, exists bool) {
	v := m.addhomeruns_allowed
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomerunsAllowed resets all changes to the "homeruns_allowed" field.
func (m *PitcherRecordMutation) ResetHomerunsAllowed() {
	m.homeruns_allowed = nil
	m.addhomeruns_allowed = nil
}

// SetWalks sets the "walks" field.
func (m *PitcherRecordMutation) SetWalks(i int) {
	m.walks = &i
	m.addwalks = nil
}

// Walks returns the value of the "walks" field in the mutation.
func (m *PitcherRecordMutation) Walks() (r int, exists bool) {
	v := m.walks
	if v == nil {
		return
	}
	return *v, true
}

// OldWalks returns the old "walks" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldWalks(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWalks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWalks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalks: %w", err)
	}
	return oldValue.Walks, nil
}

// AddWalks adds i to the "walks" field.
func (m *PitcherRecordMutation) AddWalks(i int) {
	if m.addwalks != nil {
		*m.addwalks += i
	} else {
		m.addwalks = &i
	}
}

// AddedWalks returns the value that was added to the "walks" field in this mutation.
func (m *PitcherRecordMutation) AddedWalks() (r int, exists bool) {
	v := m.addwalks
	if v == nil {
		return
	}
	return *v, true
}

// ResetWalks resets all changes to the "walks" field.
func (m *PitcherRecordMutation) ResetWalks() {
	m.walks = nil
	m.addwalks = nil
}

// SetHitByPitch sets the "hit_by_pitch" field.
func (m *PitcherRecordMutation) SetHitByPitch(i int) {
	m.hit_by_pitch = &i
	m.addhit_by_pitch = nil
}

// HitByPitch returns the value of the "hit_by_pitch" field in the mutation.
func (m *PitcherRecordMutation) HitByPitch() (r int, exists bool) {
	v := m.hit_by_pitch
	if v == nil {
		return
	}
	return *v, true
}

// OldHitByPitch returns the old "hit_by_pitch" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldHitByPitch(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHitByPitch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHitByPitch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHitByPitch: %w", err)
	}
	return oldValue.HitByPitch, nil
}

// AddHitByPitch adds i to the "hit_by_pitch" field.
func (m *PitcherRecordMutation) AddHitByPitch(i int) {
	if m.addhit_by_pitch != nil {
		*m.addhit_by_pitch += i
	} else {
		m.addhit_by_pitch = &i
	}
}

// AddedHitByPitch returns the value that was added to the "hit_by_pitch" field in this mutation.
func (m *PitcherRecordMutation) AddedHitByPitch() (r int, exists bool) {
	v := m.addhit_by_pitch
	if v == nil {
		return
	}
	return *v, true
}

// ResetHitByPitch resets all changes to the "hit_by_pitch" field.
func (m *PitcherRecordMutation) ResetHitByPitch() {
	m.hit_by_pitch = nil
	m.addhit_by_pitch = nil
}

// SetStrikeouts sets the "strikeouts" field.
func (m *PitcherRecordMutation) SetStrikeouts(i int) {
	m.strikeouts = &i
	m.addstrikeouts = nil
}

// Strikeouts returns the value of the "strikeouts" field in the mutation.
func (m *PitcherRecordMutation) Strikeouts() (r int, exists bool) {
	v := m.strikeouts
	if v == nil {
		return
	}
	return *v, true
}

// OldStrikeouts returns the old "strikeouts" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldStrikeouts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrikeouts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrikeouts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrikeouts: %w", err)
	}
	return oldValue.Strikeouts, nil
}

// AddStrikeouts adds i to the "strikeouts" field.
func (m *PitcherRecordMutation) AddStrikeouts(i int) {
	if m.addstrikeouts != nil {
		*m.addstrikeouts += i
	} else {
		m.addstrikeouts = &i
	}
}

// AddedStrikeouts returns the value that was added to the "strikeouts" field in this mutation.
func (m *PitcherRecordMutation) AddedStrikeouts() (r int, exists bool) {
	v := m.addstrikeouts
	if v == nil {
		return
	}
	return *v, true
}

// ResetStrikeouts resets all changes to the "strikeouts" field.
func (m *PitcherRecordMutation) ResetStrikeouts() {
	m.strikeouts = nil
	m.addstrikeouts = nil
}

// SetEarnedRuns sets the "earned_runs" field.
func (m *PitcherRecordMutation) SetEarnedRuns(i int) {
	m.earned_runs = &i
	m.addearned_runs = nil
}

// EarnedRuns returns the value of the "earned_runs" field in the mutation.
func (m *PitcherRecordMutation) EarnedRuns() (r int, exists bool) {
	v := m.earned_runs
	if v == nil {
		return
	}
	return *v, true
}

// OldEarnedRuns returns the old "earned_runs" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldEarnedRuns(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEarnedRuns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEarnedRuns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarnedRuns: %w", err)
	}
	return oldValue.EarnedRuns, nil
}

// AddEarnedRuns adds i to the "earned_runs" field.
func (m *PitcherRecordMutation) AddEarnedRuns(i int) {
	if m.addearned_runs != nil {
		*m.addearned_runs += i
	} else {
		m.addearned_runs = &i
	}
}

// AddedEarnedRuns returns the value that was added to the "earned_runs" field in this mutation.
func (m *PitcherRecordMutation) AddedEarnedRuns() (r int, exists bool) {
	v := m.addearned_runs
	if v == nil {
		return
	}
	return *v, true
}

// ResetEarnedRuns resets all changes to the "earned_runs" field.
func (m *PitcherRecordMutation) ResetEarnedRuns() {
	m.earned_runs = nil
	m.addearned_runs = nil
}

// SetWhip sets the "whip" field.
func (m *PitcherRecordMutation) SetWhip(f float64) {
	m.whip = &f
	m.addwhip = nil
}

// Whip returns the value of the "whip" field in the mutation.
func (m *PitcherRecordMutation) Whip() (r float64, exists bool) {
	v := m.whip
	if v == nil {
		return
	}
	return *v, true
}

// OldWhip returns the old "whip" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldWhip(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWhip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWhip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhip: %w", err)
	}
	return oldValue.Whip, nil
}

// AddWhip adds f to the "whip" field.
func (m *PitcherRecordMutation) AddWhip(f float64) {
	if m.addwhip != nil {
		*m.addwhip += f
	} else {
		m.addwhip = &f
	}
}

// AddedWhip returns the value that was added to the "whip" field in this mutation.
func (m *PitcherRecordMutation) AddedWhip() (r float64, exists bool) {
	v := m.addwhip
	if v == nil {
		return
	}
	return *v, true
}

// ClearWhip clears the value of the "whip" field.
func (m *PitcherRecordMutation) ClearWhip() {
	m.whip = nil
	m.addwhip = nil
	m.clearedFields[pitcherrecord.FieldWhip] = struct{}{}
}

// WhipCleared returns if the "whip" field was cleared in this mutation.
func (m *PitcherRecordMutation) WhipCleared() bool {
	_, ok := m.clearedFields[pitcherrecord.FieldWhip]
	return ok
}

// ResetWhip resets all changes to the "whip" field.
func (m *PitcherRecordMutation) ResetWhip() {
	m.whip = nil
	m.addwhip = nil
	delete(m.clearedFields, pitcherrecord.FieldWhip)
}

// SetOpponentAvg sets the "opponent_avg" field.
func (m *PitcherRecordMutation) SetOpponentAvg(f float64) {
	m.opponent_avg = &f
	m.addopponent_avg = nil
}

// OpponentAvg returns the value of the "opponent_avg" field in the mutation.
func (m *PitcherRecordMutation) OpponentAvg() (r float64, exists bool) {
	v := m.opponent_avg
	if v == nil {
		return
	}
	return *v, true
}

// OldOpponentAvg returns the old "opponent_avg" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldOpponentAvg(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpponentAvg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpponentAvg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpponentAvg: %w", err)
	}
	return oldValue.OpponentAvg, nil
}

// AddOpponentAvg adds f to the "opponent_avg" field.
func (m *PitcherRecordMutation) AddOpponentAvg(f float64) {
	if m.addopponent_avg != nil {
		*m.addopponent_avg += f
	} else {
		m.addopponent_avg = &f
	}
}

// AddedOpponentAvg returns the value that was added to the "opponent_avg" field in this mutation.
func (m *PitcherRecordMutation) AddedOpponentAvg() (r float64, exists bool) {
	v := m.addopponent_avg
	if v == nil {
		return
	}
	return *v, true
}

// ClearOpponentAvg clears the value of the "opponent_avg" field.
func (m *PitcherRecordMutation) ClearOpponentAvg() {
	m.opponent_avg = nil
	m.addopponent_avg = nil
	m.clearedFields[pitcherrecord.FieldOpponentAvg] = struct{}{}
}

// OpponentAvgCleared returns if the "opponent_avg" field was cleared in this mutation.
func (m *PitcherRecordMutation) OpponentAvgCleared() bool {
	_, ok := m.clearedFields[pitcherrecord.FieldOpponentAvg]
	return ok
}

// ResetOpponentAvg resets all changes to the "opponent_avg" field.
func (m *PitcherRecordMutation) ResetOpponentAvg() {
	m.opponent_avg = nil
	m.addopponent_avg = nil
	delete(m.clearedFields, pitcherrecord.FieldOpponentAvg)
}

// SetStrikeoutRate sets the "strikeout_rate" field.
func (m *PitcherRecordMutation) SetStrikeoutRate(f float64) {
	m.strikeout_rate = &f
	m.addstrikeout_rate = nil
}

// StrikeoutRate returns the value of the "strikeout_rate" field in the mutation.
func (m *PitcherRecordMutation) StrikeoutRate() (r float64, exists bool) {
	v := m.strikeout_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldStrikeoutRate returns the old "strikeout_rate" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldStrikeoutRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrikeoutRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrikeoutRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrikeoutRate: %w", err)
	}
	return oldValue.StrikeoutRate, nil
}

// AddStrikeoutRate adds f to the "strikeout_rate" field.
func (m *PitcherRecordMutation) AddStrikeoutRate(f float64) {
	if m.addstrikeout_rate != nil {
		*m.addstrikeout_rate += f
	} else {
		m.addstrikeout_rate = &f
	}
}

// AddedStrikeoutRate returns the value that was added to the "strikeout_rate" field in this mutation.
func (m *PitcherRecordMutation) AddedStrikeoutRate() (r float64, exists bool) {
	v := m.addstrikeout_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearStrikeoutRate clears the value of the "strikeout_rate" field.
func (m *PitcherRecordMutation) ClearStrikeoutRate() {
	m.strikeout_rate = nil
	m.addstrikeout_rate = nil
	m.clearedFields[pitcherrecord.FieldStrikeoutRate] = struct{}{}
}

// StrikeoutRateCleared returns if the "strikeout_rate" field was cleared in this mutation.
func (m *PitcherRecordMutation) StrikeoutRateCleared() bool {
	_, ok := m.clearedFields[pitcherrecord.FieldStrikeoutRate]
	return ok
}

// ResetStrikeoutRate resets all changes to the "strikeout_rate" field.
func (m *PitcherRecordMutation) ResetStrikeoutRate() {
	m.strikeout_rate = nil
	m.addstrikeout_rate = nil
	delete(m.clearedFields, pitcherrecord.FieldStrikeoutRate)
}

// SetCreatedAt sets the "created_at" field.
func (m *PitcherRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PitcherRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PitcherRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PitcherRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PitcherRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PitcherRecord entity.
// If the PitcherRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PitcherRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PitcherRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PitcherRecordMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PitcherRecordMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PitcherRecordMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PitcherRecordMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PitcherRecordMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PitcherRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetGameID sets the "game" edge to the Game entity by id.
func (m *PitcherRecordMutation) SetGameID(id int) {
	m.game = &id
}

// ClearGame clears the "game" edge to the Game entity.
func (m *PitcherRecordMutation) ClearGame() {
	m.clearedgame = true
}

// GameCleared reports if the "game" edge to the Game entity was cleared.
func (m *PitcherRecordMutation) GameCleared() bool {
	return m.clearedgame
}

// GameID returns the "game" edge ID in the mutation.
func (m *PitcherRecordMutation) GameID() (id int, exists bool) {
	if m.game != nil {
		return *m.game, true
	}
	return
}

// GameIDs returns the "game" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GameID instead. It exists only for internal usage by the builders.
func (m *PitcherRecordMutation) GameIDs() (ids []int) {
	if id := m.game; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGame resets all changes to the "game" edge.
func (m *PitcherRecordMutation) ResetGame() {
	m.game = nil
	m.clearedgame = false
}

// Where appends a list predicates to the PitcherRecordMutation builder.
func (m *PitcherRecordMutation) Where(ps ...predicate.PitcherRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PitcherRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PitcherRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PitcherRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PitcherRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PitcherRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PitcherRecord).
func (m *PitcherRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PitcherRecordMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.games != nil {
		fields = append(fields, pitcherrecord.FieldGames)
	}
	if m.era != nil {
		fields = append(fields, pitcherrecord.FieldEra)
	}
	if m.wins != nil {
		fields = append(fields, pitcherrecord.FieldWins)
	}
	if m.losses != nil {
		fields = append(fields, pitcherrecord.FieldLosses)
	}
	if m.saves != nil {
		fields = append(fields, pitcherrecord.FieldSaves)
	}
	if m.holds != nil {
		fields = append(fields, pitcherrecord.FieldHolds)
	}
	if m.winning_pct != nil {
		fields = append(fields, pitcherrecord.FieldWinningPct)
	}
	if m.batters_faced != nil {
		fields = append(fields, pitcherrecord.FieldBattersFaced)
	}
	if m.opponent_at_bats != nil {
		fields = append(fields, pitcherrecord.FieldOpponentAtBats)
	}
	if m.innings != nil {
		fields = append(fields, pitcherrecord.FieldInnings)
	}
	if m.hits_allowed != nil {
		fields = append(fields, pitcherrecord.FieldHitsAllowed)
	}
	if m.homeruns_allowed != nil {
		fields = append(fields, pitcherrecord.FieldHomerunsAllowed)
	}
	if m.walks != nil {
		fields = append(fields, pitcherrecord.FieldWalks)
	}
	if m.hit_by_pitch != nil {
		fields = append(fields, pitcherrecord.FieldHitByPitch)
	}
	if m.strikeouts != nil {
		fields = append(fields, pitcherrecord.FieldStrikeouts)
	}
	if m.earned_runs != nil {
		fields = append(fields, pitcherrecord.FieldEarnedRuns)
	}
	if m.whip != nil {
		fields = append(fields, pitcherrecord.FieldWhip)
	}
	if m.opponent_avg != nil {
		fields = append(fields, pitcherrecord.FieldOpponentAvg)
	}
	if m.strikeout_rate != nil {
		fields = append(fields, pitcherrecord.FieldStrikeoutRate)
	}
	if m.created_at != nil {
		fields = append(fields, pitcherrecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pitcherrecord.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PitcherRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pitcherrecord.FieldGames:
		return m.Games()
	case pitcherrecord.FieldEra:
		return m.Era()
	case pitcherrecord.FieldWins:
		return m.Wins()
	case pitcherrecord.FieldLosses:
		return m.Losses()
	case pitcherrecord.FieldSaves:
		return m.Saves()
	case pitcherrecord.FieldHolds:
		return m.Holds()
	case pitcherrecord.FieldWinningPct:
		return m.WinningPct()
	case pitcherrecord.FieldBattersFaced:
		return m.BattersFaced()
	case pitcherrecord.FieldOpponentAtBats:
		return m.OpponentAtBats()
	case pitcherrecord.FieldInnings:
		return m.Innings()
	case pitcherrecord.FieldHitsAllowed:
		return m.HitsAllowed()
	case pitcherrecord.FieldHomerunsAllowed:
		return m.HomerunsAllowed()
	case pitcherrecord.FieldWalks:
		return m.Walks()
	case pitcherrecord.FieldHitByPitch:
		return m.HitByPitch()
	case pitcherrecord.FieldStrikeouts:
		return m.Strikeouts()
	case pitcherrecord.FieldEarnedRuns:
		return m.EarnedRuns()
	case pitcherrecord.FieldWhip:
		return m.Whip()
	case pitcherrecord.FieldOpponentAvg:
		return m.OpponentAvg()
	case pitcherrecord.FieldStrikeoutRate:
		return m.StrikeoutRate()
	case pitcherrecord.FieldCreatedAt:
		return m.CreatedAt()
	case pitcherrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PitcherRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pitcherrecord.FieldGames:
		return m.OldGames(ctx)
	case pitcherrecord.FieldEra:
		return m.OldEra(ctx)
	case pitcherrecord.FieldWins:
		return m.OldWins(ctx)
	case pitcherrecord.FieldLosses:
		return m.OldLosses(ctx)
	case pitcherrecord.FieldSaves:
		return m.OldSaves(ctx)
	case pitcherrecord.FieldHolds:
		return m.OldHolds(ctx)
	case pitcherrecord.FieldWinningPct:
		return m.OldWinningPct(ctx)
	case pitcherrecord.FieldBattersFaced:
		return m.OldBattersFaced(ctx)
	case pitcherrecord.FieldOpponentAtBats:
		return m.OldOpponentAtBats(ctx)
	case pitcherrecord.FieldInnings:
		return m.OldInnings(ctx)
	case pitcherrecord.FieldHitsAllowed:
		return m.OldHitsAllowed(ctx)
	case pitcherrecord.FieldHomerunsAllowed:
		return m.OldHomerunsAllowed(ctx)
	case pitcherrecord.FieldWalks:
		return m.OldWalks(ctx)
	case pitcherrecord.FieldHitByPitch:
		return m.OldHitByPitch(ctx)
	case pitcherrecord.FieldStrikeouts:
		return m.OldStrikeouts(ctx)
	case pitcherrecord.FieldEarnedRuns:
		return m.OldEarnedRuns(ctx)
	case pitcherrecord.FieldWhip:
		return m.OldWhip(ctx)
	case pitcherrecord.FieldOpponentAvg:
		return m.OldOpponentAvg(ctx)
	case pitcherrecord.FieldStrikeoutRate:
		return m.OldStrikeoutRate(ctx)
	case pitcherrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pitcherrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PitcherRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PitcherRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pitcherrecord.FieldGames:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGames(v)
		return nil
	case pitcherrecord.FieldEra:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEra(v)
		return nil
	case pitcherrecord.FieldWins:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWins(v)
		return nil
	case pitcherrecord.FieldLosses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLosses(v)
		return nil
	case pitcherrecord.FieldSaves:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaves(v)
		return nil
	case pitcherrecord.FieldHolds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHolds(v)
		return nil
	case pitcherrecord.FieldWinningPct:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWinningPct(v)
		return nil
	case pitcherrecord.FieldBattersFaced:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBattersFaced(v)
		return nil
	case pitcherrecord.FieldOpponentAtBats:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpponentAtBats(v)
		return nil
	case pitcherrecord.FieldInnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInnings(v)
		return nil
	case pitcherrecord.FieldHitsAllowed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHitsAllowed(v)
		return nil
	case pitcherrecord.FieldHomerunsAllowed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomerunsAllowed(v)
		return nil
	case pitcherrecord.FieldWalks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalks(v)
		return nil
	case pitcherrecord.FieldHitByPitch:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHitByPitch(v)
		return nil
	case pitcherrecord.FieldStrikeouts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrikeouts(v)
		return nil
	case pitcherrecord.FieldEarnedRuns:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarnedRuns(v)
		return nil
	case pitcherrecord.FieldWhip:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhip(v)
		return nil
	case pitcherrecord.FieldOpponentAvg:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpponentAvg(v)
		return nil
	case pitcherrecord.FieldStrikeoutRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrikeoutRate(v)
		return nil
	case pitcherrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pitcherrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PitcherRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PitcherRecordMutation) AddedFields() []string {
	var fields []string
	if m.addgames != nil {
		fields = append(fields, pitcherrecord.FieldGames)
	}
	if m.addera != nil {
		fields = append(fields, pitcherrecord.FieldEra)
	}
	if m.addwins != nil {
		fields = append(fields, pitcherrecord.FieldWins)
	}
	if m.addlosses != nil {
		fields = append(fields, pitcherrecord.FieldLosses)
	}
	if m.addsaves != nil {
		fields = append(fields, pitcherrecord.FieldSaves)
	}
	if m.addholds != nil {
		fields = append(fields, pitcherrecord.FieldHolds)
	}
	if m.addwinning_pct != nil {
		fields = append(fields, pitcherrecord.FieldWinningPct)
	}
	if m.addbatters_faced != nil {
		fields = append(fields, pitcherrecord.FieldBattersFaced)
	}
	if m.addopponent_at_bats != nil {
		fields = append(fields, pitcherrecord.FieldOpponentAtBats)
	}
	if m.addinnings != nil {
		fields = append(fields, pitcherrecord.FieldInnings)
	}
	if m.addhits_allowed != nil {
		fields = append(fields, pitcherrecord.FieldHitsAllowed)
	}
	if m.addhomeruns_allowed != nil {
		fields = append(fields, pitcherrecord.FieldHomerunsAllowed)
	}
	if m.addwalks != nil {
		fields = append(fields, pitcherrecord.FieldWalks)
	}
	if m.addhit_by_pitch != nil {
		fields = append(fields, pitcherrecord.FieldHitByPitch)
	}
	if m.addstrikeouts != nil {
		fields = append(fields, pitcherrecord.FieldStrikeouts)
	}
	if m.addearned_runs != nil {
		fields = append(fields, pitcherrecord.FieldEarnedRuns)
	}
	if m.addwhip != nil {
		fields = append(fields, pitcherrecord.FieldWhip)
	}
	if m.addopponent_avg != nil {
		fields = append(fields, pitcherrecord.FieldOpponentAvg)
	}
	if m.addstrikeout_rate != nil {
		fields = append(fields, pitcherrecord.FieldStrikeoutRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PitcherRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pitcherrecord.FieldGames:
		return m.AddedGames()
	case pitcherrecord.FieldEra:
		return m.AddedEra()
	case pitcherrecord.FieldWins:
		return m.AddedWins()
	case pitcherrecord.FieldLosses:
		return m.AddedLosses()
	case pitcherrecord.FieldSaves:
		return m.AddedSaves()
	case pitcherrecord.FieldHolds:
		return m.AddedHolds()
	case pitcherrecord.FieldWinningPct:
		return m.AddedWinningPct()
	case pitcherrecord.FieldBattersFaced:
		return m.AddedBattersFaced()
	case pitcherrecord.FieldOpponentAtBats:
		return m.AddedOpponentAtBats()
	case pitcherrecord.FieldInnings:
		return m.AddedInnings()
	case pitcherrecord.FieldHitsAllowed:
		return m.AddedHitsAllowed()
	case pitcherrecord.FieldHomerunsAllowed:
		return m.AddedHomerunsAllowed()
	case pitcherrecord.FieldWalks:
		return m.AddedWalks()
	case pitcherrecord.FieldHitByPitch:
		return m.AddedHitByPitch()
	case pitcherrecord.FieldStrikeouts:
		return m.AddedStrikeouts()
	case pitcherrecord.FieldEarnedRuns:
		return m.AddedEarnedRuns()
	case pitcherrecord.FieldWhip:
		return m.AddedWhip()
	case pitcherrecord.FieldOpponentAvg:
		return m.AddedOpponentAvg()
	case pitcherrecord.FieldStrikeoutRate:
		return m.AddedStrikeoutRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PitcherRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pitcherrecord.FieldGames:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGames(v)
		return nil
	case pitcherrecord.FieldEra:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEra(v)
		return nil
	case pitcherrecord.FieldWins:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWins(v)
		return nil
	case pitcherrecord.FieldLosses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLosses(v)
		return nil
	case pitcherrecord.FieldSaves:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSaves(v)
		return nil
	case pitcherrecord.FieldHolds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHolds(v)
		return nil
	case pitcherrecord.FieldWinningPct:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWinningPct(v)
		return nil
	case pitcherrecord.FieldBattersFaced:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBattersFaced(v)
		return nil
	case pitcherrecord.FieldOpponentAtBats:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpponentAtBats(v)
		return nil
	case pitcherrecord.FieldInnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInnings(v)
		return nil
	case pitcherrecord.FieldHitsAllowed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHitsAllowed(v)
		return nil
	case pitcherrecord.FieldHomerunsAllowed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomerunsAllowed(v)
		return nil
	case pitcherrecord.FieldWalks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWalks(v)
		return nil
	case pitcherrecord.FieldHitByPitch:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHitByPitch(v)
		return nil
	case pitcherrecord.FieldStrikeouts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStrikeouts(v)
		return nil
	case pitcherrecord.FieldEarnedRuns:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEarnedRuns(v)
		return nil
	case pitcherrecord.FieldWhip:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWhip(v)
		return nil
	case pitcherrecord.FieldOpponentAvg:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpponentAvg(v)
		return nil
	case pitcherrecord.FieldStrikeoutRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStrikeoutRate(v)
		return nil
	}
	return fmt.Errorf("unknown PitcherRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PitcherRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pitcherrecord.FieldEra) {
		fields = append(fields, pitcherrecord.FieldEra)
	}
	if m.FieldCleared(pitcherrecord.FieldWinningPct) {
		fields = append(fields, pitcherrecord.FieldWinningPct)
	}
	if m.FieldCleared(pitcherrecord.FieldWhip) {
		fields = append(fields, pitcherrecord.FieldWhip)
	}
	if m.FieldCleared(pitcherrecord.FieldOpponentAvg) {
		fields = append(fields, pitcherrecord.FieldOpponentAvg)
	}
	if m.FieldCleared(pitcherrecord.FieldStrikeoutRate) {
		fields = append(fields, pitcherrecord.FieldStrikeoutRate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PitcherRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PitcherRecordMutation) ClearField(name string) error {
	switch name {
	case pitcherrecord.FieldEra:
		m.ClearEra()
		return nil
	case pitcherrecord.FieldWinningPct:
		m.ClearWinningPct()
		return nil
	case pitcherrecord.FieldWhip:
		m.ClearWhip()
		return nil
	case pitcherrecord.FieldOpponentAvg:
		m.ClearOpponentAvg()
		return nil
	case pitcherrecord.FieldStrikeoutRate:
		m.ClearStrikeoutRate()
		return nil
	}
	return fmt.Errorf("unknown PitcherRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PitcherRecordMutation) ResetField(name string) error {
	switch name {
	case pitcherrecord.FieldGames:
		m.ResetGames()
		return nil
	case pitcherrecord.FieldEra:
		m.ResetEra()
		return nil
	case pitcherrecord.FieldWins:
		m.ResetWins()
		return nil
	case pitcherrecord.FieldLosses:
		m.ResetLosses()
		return nil
	case pitcherrecord.FieldSaves:
		m.ResetSaves()
		return nil
	case pitcherrecord.FieldHolds:
		m.ResetHolds()
		return nil
	case pitcherrecord.FieldWinningPct:
		m.ResetWinningPct()
		return nil
	case pitcherrecord.FieldBattersFaced:
		m.ResetBattersFaced()
		return nil
	case pitcherrecord.FieldOpponentAtBats:
		m.ResetOpponentAtBats()
		return nil
	case pitcherrecord.FieldInnings:
		m.ResetInnings()
		return nil
	case pitcherrecord.FieldHitsAllowed:
		m.ResetHitsAllowed()
		return nil
	case pitcherrecord.FieldHomerunsAllowed:
		m.ResetHomerunsAllowed()
		return nil
	case pitcherrecord.FieldWalks:
		m.ResetWalks()
		return nil
	case pitcherrecord.FieldHitByPitch:
		m.ResetHitByPitch()
		return nil
	case pitcherrecord.FieldStrikeouts:
		m.ResetStrikeouts()
		return nil
	case pitcherrecord.FieldEarnedRuns:
		m.ResetEarnedRuns()
		return nil
	case pitcherrecord.FieldWhip:
		m.ResetWhip()
		return nil
	case pitcherrecord.FieldOpponentAvg:
		m.ResetOpponentAvg()
		return nil
	case pitcherrecord.FieldStrikeoutRate:
		m.ResetStrikeoutRate()
		return nil
	case pitcherrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pitcherrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PitcherRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PitcherRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, pitcherrecord.EdgeUser)
	}
	if m.game != nil {
		edges = append(edges, pitcherrecord.EdgeGame)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PitcherRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pitcherrecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case pitcherrecord.EdgeGame:
		if id := m.game; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PitcherRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PitcherRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PitcherRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, pitcherrecord.EdgeUser)
	}
	if m.clearedgame {
		edges = append(edges, pitcherrecord.EdgeGame)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PitcherRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case pitcherrecord.EdgeUser:
		return m.cleareduser
	case pitcherrecord.EdgeGame:
		return m.clearedgame
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PitcherRecordMutation) ClearEdge(name string) error {
	switch name {
	case pitcherrecord.EdgeUser:
		m.ClearUser()
		return nil
	case pitcherrecord.EdgeGame:
		m.ClearGame()
		return nil
	}
	return fmt.Errorf("unknown PitcherRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PitcherRecordMutation) ResetEdge(name string) error {
	switch name {
	case pitcherrecord.EdgeUser:
		m.ResetUser()
		return nil
	case pitcherrecord.EdgeGame:
		m.ResetGame()
		return nil
	}
	return fmt.Errorf("unknown PitcherRecord edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	email                   *string
	password                *string
	name                    *string
	team                    *string
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	games                   map[int]struct{}
	removedgames            map[int]struct{}
	clearedgames            bool
	batting_records         map[int]struct{}
	removedbatting_records  map[int]struct{}
	clearedbatting_records  bool
	pitching_records        map[int]struct{}
	removedpitching_records map[int]struct{}
	clearedpitching_records bool
	done                    bool
	oldValue                func(context.Context) (*User, error)
	predicates              []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetTeam sets the "team" field.
func (m *UserMutation) SetTeam(s string) {
	m.team = &s
}

// Team returns the value of the "team" field in the mutation.
func (m *UserMutation) Team() (r string, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeam returns the old "team" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTeam(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeam: %w", err)
	}
	return oldValue.Team, nil
}

// ClearTeam clears the value of the "team" field.
func (m *UserMutation) ClearTeam() {
	m.team = nil
	m.clearedFields[user.FieldTeam] = struct{}{}
}

// TeamCleared returns if the "team" field was cleared in this mutation.
func (m *UserMutation) TeamCleared() bool {
	_, ok := m.clearedFields[user.FieldTeam]
	return ok
}

// ResetTeam resets all changes to the "team" field.
func (m *UserMutation) ResetTeam() {
	m.team = nil
	delete(m.clearedFields, user.FieldTeam)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGameIDs adds the "games" edge to the Game entity by ids.
func (m *UserMutation) AddGameIDs(ids ...int) {
	if m.games == nil {
		m.games = make(map[int]struct{})
	}
	for i := range ids {
		m.games[ids[i]] = struct{}{}
	}
}

// ClearGames clears the "games" edge to the Game entity.
func (m *UserMutation) ClearGames() {
	m.clearedgames = true
}

// GamesCleared reports if the "games" edge to the Game entity was cleared.
func (m *UserMutation) GamesCleared() bool {
	return m.clearedgames
}

// RemoveGameIDs removes the "games" edge to the Game entity by IDs.
func (m *UserMutation) RemoveGameIDs(ids ...int) {
	if m.removedgames == nil {
		m.removedgames = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.games, ids[i])
		m.removedgames[ids[i]] = struct{}{}
	}
}

// RemovedGames returns the removed IDs of the "games" edge to the Game entity.
func (m *UserMutation) RemovedGamesIDs() (ids []int) {
	for id := range m.removedgames {
		ids = append(ids, id)
	}
	return
}

// GamesIDs returns the "games" edge IDs in the mutation.
func (m *UserMutation) GamesIDs() (ids []int) {
	for id := range m.games {
		ids = append(ids, id)
	}
	return
}

// ResetGames resets all changes to the "games" edge.
func (m *UserMutation) ResetGames() {
	m.games = nil
	m.clearedgames = false
	m.removedgames = nil
}

// AddBattingRecordIDs adds the "batting_records" edge to the BatterRecord entity by ids.
func (m *UserMutation) AddBattingRecordIDs(ids ...int) {
	if m.batting_records == nil {
		m.batting_records = make(map[int]struct{})
	}
	for i := range ids {
		m.batting_records[ids[i]] = struct{}{}
	}
}

// ClearBattingRecords clears the "batting_records" edge to the BatterRecord entity.
func (m *UserMutation) ClearBattingRecords() {
	m.clearedbatting_records = true
}

// BattingRecordsCleared reports if the "batting_records" edge to the BatterRecord entity was cleared.
func (m *UserMutation) BattingRecordsCleared() bool {
	return m.clearedbatting_records
}

// RemoveBattingRecordIDs removes the "batting_records" edge to the BatterRecord entity by IDs.
func (m *UserMutation) RemoveBattingRecordIDs(ids ...int) {
	if m.removedbatting_records == nil {
		m.removedbatting_records = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.batting_records, ids[i])
		m.removedbatting_records[ids[i]] = struct{}{}
	}
}

// RemovedBattingRecords returns the removed IDs of the "batting_records" edge to the BatterRecord entity.
func (m *UserMutation) RemovedBattingRecordsIDs() (ids []int) {
	for id := range m.removedbatting_records {
		ids = append(ids, id)
	}
	return
}

// BattingRecordsIDs returns the "batting_records" edge IDs in the mutation.
func (m *UserMutation) BattingRecordsIDs() (ids []int) {
	for id := range m.batting_records {
		ids = append(ids, id)
	}
	return
}

// ResetBattingRecords resets all changes to the "batting_records" edge.
func (m *UserMutation) ResetBattingRecords() {
	m.batting_records = nil
	m.clearedbatting_records = false
	m.removedbatting_records = nil
}

// AddPitchingRecordIDs adds the "pitching_records" edge to the PitcherRecord entity by ids.
func (m *UserMutation) AddPitchingRecordIDs(ids ...int) {
	if m.pitching_records == nil {
		m.pitching_records = make(map[int]struct{})
	}
	for i := range ids {
		m.pitching_records[ids[i]] = struct{}{}
	}
}

// ClearPitchingRecords clears the "pitching_records" edge to the PitcherRecord entity.
func (m *UserMutation) ClearPitchingRecords() {
	m.clearedpitching_records = true
}

// PitchingRecordsCleared reports if the "pitching_records" edge to the PitcherRecord entity was cleared.
func (m *UserMutation) PitchingRecordsCleared() bool {
	return m.clearedpitching_records
}

// RemovePitchingRecordIDs removes the "pitching_records" edge to the PitcherRecord entity by IDs.
func (m *UserMutation) RemovePitchingRecordIDs(ids ...int) {
	if m.removedpitching_records == nil {
		m.removedpitching_records = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.pitching_records, ids[i])
		m.removedpitching_records[ids[i]] = struct{}{}
	}
}

// RemovedPitchingRecords returns the removed IDs of the "pitching_records" edge to the PitcherRecord entity.
func (m *UserMutation) RemovedPitchingRecordsIDs() (ids []int) {
	for id := range m.removedpitching_records {
		ids = append(ids, id)
	}
	return
}

// PitchingRecordsIDs returns the "pitching_records" edge IDs in the mutation.
func (m *UserMutation) PitchingRecordsIDs() (ids []int) {
	for id := range m.pitching_records {
		ids = append(ids, id)
	}
	return
}

// ResetPitchingRecords resets all changes to the "pitching_records" edge.
func (m *UserMutation) ResetPitchingRecords() {
	m.pitching_records = nil
	m.clearedpitching_records = false
	m.removedpitching_records = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.team != nil {
		fields = append(fields, user.FieldTeam)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldName:
		return m.Name()
	case user.FieldTeam:
		return m.Team()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldTeam:
		return m.OldTeam(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldTeam:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeam(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldTeam) {
		fields = append(fields, user.FieldTeam)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldTeam:
		m.ResetTeam()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.games != nil {
		edges = append(edges, user.EdgeGames)
	}
	if m.batting_records != nil {
		edges = append(edges, user.EdgeBattingRecords)
	}
	if m.pitching_records != nil {
		edges = append(edges, user.EdgePitchingRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeGames:
		ids := make([]ent.Value, 0, len(m.games))
		for id := range m.games {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBattingRecords:
		ids := make([]ent.Value, 0, len(m.batting_records))
		for id := range m.batting_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePitchingRecords:
		ids := make([]ent.Value, 0, len(m.pitching_records))
		for id := range m.pitching_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedgames != nil {
		edges = append(edges, user.EdgeGames)
	}
	if m.removedbatting_records != nil {
		edges = append(edges, user.EdgeBattingRecords)
	}
	if m.removedpitching_records != nil {
		edges = append(edges, user.EdgePitchingRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeGames:
		ids := make([]ent.Value, 0, len(m.removedgames))
		for id := range m.removedgames {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBattingRecords:
		ids := make([]ent.Value, 0, len(m.removedbatting_records))
		for id := range m.removedbatting_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePitchingRecords:
		ids := make([]ent.Value, 0, len(m.removedpitching_records))
		for id := range m.removedpitching_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedgames {
		edges = append(edges, user.EdgeGames)
	}
	if m.clearedbatting_records {
		edges = append(edges, user.EdgeBattingRecords)
	}
	if m.clearedpitching_records {
		edges = append(edges, user.EdgePitchingRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeGames:
		return m.clearedgames
	case user.EdgeBattingRecords:
		return m.clearedbatting_records
	case user.EdgePitchingRecords:
		return m.clearedpitching_records
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeGames:
		m.ResetGames()
		return nil
	case user.EdgeBattingRecords:
		m.ResetBattingRecords()
		return nil
	case user.EdgePitchingRecords:
		m.ResetPitchingRecords()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
